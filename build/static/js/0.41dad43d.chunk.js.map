{"version":3,"sources":["../node_modules/graphql/jsutils/isObjectLike.mjs","../node_modules/graphql/jsutils/invariant.mjs","../node_modules/graphql/language/location.mjs","../node_modules/graphql/language/printLocation.mjs","../node_modules/graphql/error/GraphQLError.mjs","../node_modules/graphql/error/syntaxError.mjs","../node_modules/graphql/language/directiveLocation.mjs","../node_modules/graphql/language/tokenKind.mjs","../node_modules/graphql/language/lexer.mjs","../node_modules/graphql/language/parser.mjs","../../src/index.ts","../node_modules/@emotion/is-prop-valid/dist/emotion-is-prop-valid.browser.esm.js","../node_modules/@emotion/styled/base/dist/emotion-styled-base.browser.esm.js","../node_modules/@emotion/styled/dist/emotion-styled.browser.esm.js","../../../../src/react/hooks/useApolloClient.ts","../../../../src/react/parser/index.ts","../node_modules/@babel/runtime/helpers/esm/inherits.js","../node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js","../node_modules/@babel/runtime/helpers/esm/createSuper.js","../node_modules/@babel/runtime/helpers/esm/typeof.js","../node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js","../node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js","../node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js","../node_modules/@babel/runtime/helpers/esm/isNativeReflectConstruct.js","../node_modules/@babel/runtime/helpers/esm/construct.js","../node_modules/@babel/runtime/helpers/esm/wrapNativeSuper.js","../node_modules/@babel/runtime/helpers/esm/isNativeFunction.js"],"names":["isObjectLike","value","invariant","condition","message","Boolean","Error","LineRegExp","getLocation","source","position","lastLineStart","line","body","matchAll","match","index","length","column","printLocation","location","printSourceLocation","start","sourceLocation","firstLineColumnOffset","locationOffset","padStart","lineIndex","lineOffset","lineNum","columnOffset","columnNum","locationStr","name","lines","split","locationLine","subLineIndex","Math","floor","subLineColumnNum","subLines","i","push","slice","printPrefixedLines","map","subLine","existingLines","filter","undefined","padLen","max","prefix","join","toNormalizedArgs","args","firstArg","nodes","positions","path","originalError","extensions","GraphQLError","_this$nodes","_nodeLocations$","_ref","rawArgs","undefinedIfEmpty","Array","isArray","nodeLocations","node","loc","locations","pos","originalExtensions","Object","create","defineProperties","writable","enumerable","stack","defineProperty","configurable","captureStackTrace","output","this","formattedError","keys","Symbol","toStringTag","array","syntaxError","description","DirectiveLocation","TokenKind","Lexer","startOfFileToken","Token","SOF","lastToken","token","lineStart","lookahead","kind","EOF","next","nextToken","readNextToken","end","prev","COMMENT","isUnicodeScalarValue","code","isSupplementaryCodePoint","isLeadingSurrogate","charCodeAt","isTrailingSurrogate","printCodePointAt","lexer","codePointAt","char","String","fromCodePoint","toString","toUpperCase","createToken","col","bodyLength","readComment","BANG","DOLLAR","AMP","PAREN_L","PAREN_R","SPREAD","COLON","EQUALS","AT","BRACKET_L","BRACKET_R","BRACE_L","PIPE","BRACE_R","readBlockString","readString","isDigit","readNumber","isNameStart","readName","firstCode","isFloat","readDigits","FLOAT","INT","chunkStart","STRING","escape","readEscapedUnicodeVariableWidth","readEscapedUnicodeFixedWidth","readEscapedCharacter","size","point","readHexDigit","read16BitHexCode","trailingCode","currentLine","blockLines","BLOCK_STRING","dedentBlockStringLines","isNameContinue","NAME","Parser","options","sourceObj","isSource","Source","_lexer","_options","expectToken","Kind","DOCUMENT","definitions","many","parseDefinition","peek","parseOperationDefinition","hasDescription","peekDescription","keywordToken","parseSchemaDefinition","parseScalarTypeDefinition","parseObjectTypeDefinition","parseInterfaceTypeDefinition","parseUnionTypeDefinition","parseEnumTypeDefinition","parseInputObjectTypeDefinition","parseDirectiveDefinition","parseFragmentDefinition","parseTypeSystemExtension","unexpected","OPERATION_DEFINITION","operation","OperationTypeNode","QUERY","variableDefinitions","directives","selectionSet","parseSelectionSet","parseOperationType","parseName","parseVariableDefinitions","parseDirectives","operationToken","MUTATION","SUBSCRIPTION","optionalMany","parseVariableDefinition","VARIABLE_DEFINITION","variable","parseVariable","type","parseTypeReference","defaultValue","expectOptionalToken","parseConstValueLiteral","parseConstDirectives","VARIABLE","SELECTION_SET","selections","parseSelection","parseFragment","parseField","alias","nameOrAlias","FIELD","arguments","parseArguments","isConst","item","parseConstArgument","parseArgument","ARGUMENT","parseValueLiteral","hasTypeCondition","expectOptionalKeyword","FRAGMENT_SPREAD","parseFragmentName","INLINE_FRAGMENT","typeCondition","parseNamedType","_this$_options","expectKeyword","allowLegacyFragmentVariables","FRAGMENT_DEFINITION","parseList","parseObject","advance","parseStringLiteral","BOOLEAN","NULL","ENUM","varName","block","LIST","values","any","OBJECT","fields","parseObjectField","OBJECT_FIELD","parseDirective","DIRECTIVE","innerType","LIST_TYPE","NON_NULL_TYPE","NAMED_TYPE","parseDescription","operationTypes","parseOperationTypeDefinition","SCHEMA_DEFINITION","OPERATION_TYPE_DEFINITION","SCALAR_TYPE_DEFINITION","interfaces","parseImplementsInterfaces","parseFieldsDefinition","OBJECT_TYPE_DEFINITION","delimitedMany","parseFieldDefinition","parseArgumentDefs","FIELD_DEFINITION","parseInputValueDef","INPUT_VALUE_DEFINITION","INTERFACE_TYPE_DEFINITION","types","parseUnionMemberTypes","UNION_TYPE_DEFINITION","parseEnumValuesDefinition","ENUM_TYPE_DEFINITION","parseEnumValueDefinition","parseEnumValueName","ENUM_VALUE_DEFINITION","getTokenDesc","parseInputFieldsDefinition","INPUT_OBJECT_TYPE_DEFINITION","parseSchemaExtension","parseScalarTypeExtension","parseObjectTypeExtension","parseInterfaceTypeExtension","parseUnionTypeExtension","parseEnumTypeExtension","parseInputObjectTypeExtension","SCHEMA_EXTENSION","SCALAR_TYPE_EXTENSION","OBJECT_TYPE_EXTENSION","INTERFACE_TYPE_EXTENSION","UNION_TYPE_EXTENSION","ENUM_TYPE_EXTENSION","INPUT_OBJECT_TYPE_EXTENSION","repeatable","parseDirectiveLocations","DIRECTIVE_DEFINITION","parseDirectiveLocation","prototype","hasOwnProperty","call","startToken","_this$_options2","noLocation","Location","getTokenKindDesc","atToken","openKind","parseFn","closeKind","delimiterKind","isPunctuatorTokenKind","parseDocument","reactPropsRegex","isPropValid","memoize","prop","test","testOmitPropsOnStringTag","testOmitPropsOnComponent","key","getDefaultShouldForwardProp","tag","composeShouldForwardProps","isReal","shouldForwardProp","optionsShouldForwardProp","__emotion_forwardProp","propName","Noop","createStyled","identifierName","targetClassName","__emotion_real","baseTag","__emotion_base","label","target","defaultShouldForwardProp","shouldUseAs","styles","__emotion_styles","raw","apply","process","len","Styled","withEmotionCache","props","cache","ref","finalTag","as","className","classInterpolations","mergedProps","theme","useContext","ThemeContext","getRegisteredStyles","registered","serialized","serializeStyles","concat","insertStyles","finalShouldForwardProp","newProps","_key","ele","createElement","possiblyStyleElement","Fragment","displayName","defaultProps","withComponent","nextTag","nextOptions","_extends","newStyled","bind","forEach","tagName","useApolloClient","override","context","client","DocumentType","Map","operationName","Query","Mutation","Subscription","document","variables","cached","get","fragments","x","queries","mutations","subscriptions","definition","_inherits","subClass","superClass","TypeError","constructor","_possibleConstructorReturn","self","assertThisInitialized","_createSuper","Derived","hasNativeReflectConstruct","isNativeReflectConstruct","result","Super","getPrototypeOf","NewTarget","Reflect","construct","_typeof","obj","iterator","_getPrototypeOf","o","setPrototypeOf","__proto__","_assertThisInitialized","ReferenceError","_setPrototypeOf","p","_isNativeReflectConstruct","sham","Proxy","valueOf","e","Parent","Class","a","instance","Function","_cache","fn","indexOf","has","set","Wrapper"],"mappings":"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","file":"static/js/0.41dad43d.chunk.js","sourcesContent":["/**\n * Return true if `value` is object-like. A value is object-like if it's not\n * `null` and has a `typeof` result of \"object\".\n */\nexport function isObjectLike(value) {\n  return typeof value == 'object' && value !== null;\n}\n","export function invariant(condition, message) {\n  const booleanCondition = Boolean(condition);\n\n  if (!booleanCondition) {\n    throw new Error(\n      message != null ? message : 'Unexpected invariant triggered.',\n    );\n  }\n}\n","import { invariant } from '../jsutils/invariant.mjs';\nconst LineRegExp = /\\r\\n|[\\n\\r]/g;\n/**\n * Represents a location in a Source.\n */\n\n/**\n * Takes a Source and a UTF-8 character offset, and returns the corresponding\n * line and column as a SourceLocation.\n */\nexport function getLocation(source, position) {\n  let lastLineStart = 0;\n  let line = 1;\n\n  for (const match of source.body.matchAll(LineRegExp)) {\n    typeof match.index === 'number' || invariant(false);\n\n    if (match.index >= position) {\n      break;\n    }\n\n    lastLineStart = match.index + match[0].length;\n    line += 1;\n  }\n\n  return {\n    line,\n    column: position + 1 - lastLineStart,\n  };\n}\n","import { getLocation } from './location.mjs';\n\n/**\n * Render a helpful description of the location in the GraphQL Source document.\n */\nexport function printLocation(location) {\n  return printSourceLocation(\n    location.source,\n    getLocation(location.source, location.start),\n  );\n}\n/**\n * Render a helpful description of the location in the GraphQL Source document.\n */\n\nexport function printSourceLocation(source, sourceLocation) {\n  const firstLineColumnOffset = source.locationOffset.column - 1;\n  const body = ''.padStart(firstLineColumnOffset) + source.body;\n  const lineIndex = sourceLocation.line - 1;\n  const lineOffset = source.locationOffset.line - 1;\n  const lineNum = sourceLocation.line + lineOffset;\n  const columnOffset = sourceLocation.line === 1 ? firstLineColumnOffset : 0;\n  const columnNum = sourceLocation.column + columnOffset;\n  const locationStr = `${source.name}:${lineNum}:${columnNum}\\n`;\n  const lines = body.split(/\\r\\n|[\\n\\r]/g);\n  const locationLine = lines[lineIndex]; // Special case for minified documents\n\n  if (locationLine.length > 120) {\n    const subLineIndex = Math.floor(columnNum / 80);\n    const subLineColumnNum = columnNum % 80;\n    const subLines = [];\n\n    for (let i = 0; i < locationLine.length; i += 80) {\n      subLines.push(locationLine.slice(i, i + 80));\n    }\n\n    return (\n      locationStr +\n      printPrefixedLines([\n        [`${lineNum} |`, subLines[0]],\n        ...subLines.slice(1, subLineIndex + 1).map((subLine) => ['|', subLine]),\n        ['|', '^'.padStart(subLineColumnNum)],\n        ['|', subLines[subLineIndex + 1]],\n      ])\n    );\n  }\n\n  return (\n    locationStr +\n    printPrefixedLines([\n      // Lines specified like this: [\"prefix\", \"string\"],\n      [`${lineNum - 1} |`, lines[lineIndex - 1]],\n      [`${lineNum} |`, locationLine],\n      ['|', '^'.padStart(columnNum)],\n      [`${lineNum + 1} |`, lines[lineIndex + 1]],\n    ])\n  );\n}\n\nfunction printPrefixedLines(lines) {\n  const existingLines = lines.filter(([_, line]) => line !== undefined);\n  const padLen = Math.max(...existingLines.map(([prefix]) => prefix.length));\n  return existingLines\n    .map(([prefix, line]) => prefix.padStart(padLen) + (line ? ' ' + line : ''))\n    .join('\\n');\n}\n","import { isObjectLike } from '../jsutils/isObjectLike.mjs';\nimport { getLocation } from '../language/location.mjs';\nimport {\n  printLocation,\n  printSourceLocation,\n} from '../language/printLocation.mjs';\n\nfunction toNormalizedArgs(args) {\n  const firstArg = args[0];\n\n  if (firstArg == null || 'kind' in firstArg || 'length' in firstArg) {\n    return {\n      nodes: firstArg,\n      source: args[1],\n      positions: args[2],\n      path: args[3],\n      originalError: args[4],\n      extensions: args[5],\n    };\n  }\n\n  return firstArg;\n}\n/**\n * A GraphQLError describes an Error found during the parse, validate, or\n * execute phases of performing a GraphQL operation. In addition to a message\n * and stack trace, it also includes information about the locations in a\n * GraphQL document and/or execution result that correspond to the Error.\n */\n\nexport class GraphQLError extends Error {\n  /**\n   * An array of `{ line, column }` locations within the source GraphQL document\n   * which correspond to this error.\n   *\n   * Errors during validation often contain multiple locations, for example to\n   * point out two things with the same name. Errors during execution include a\n   * single location, the field which produced the error.\n   *\n   * Enumerable, and appears in the result of JSON.stringify().\n   */\n\n  /**\n   * An array describing the JSON-path into the execution response which\n   * corresponds to this error. Only included for errors during execution.\n   *\n   * Enumerable, and appears in the result of JSON.stringify().\n   */\n\n  /**\n   * An array of GraphQL AST Nodes corresponding to this error.\n   */\n\n  /**\n   * The source GraphQL document for the first location of this error.\n   *\n   * Note that if this Error represents more than one node, the source may not\n   * represent nodes after the first node.\n   */\n\n  /**\n   * An array of character offsets within the source GraphQL document\n   * which correspond to this error.\n   */\n\n  /**\n   * The original error thrown from a field resolver during execution.\n   */\n\n  /**\n   * Extension fields to add to the formatted error.\n   */\n\n  /**\n   * @deprecated Please use the `GraphQLErrorArgs` constructor overload instead.\n   */\n  constructor(message, ...rawArgs) {\n    var _this$nodes, _nodeLocations$, _ref;\n\n    const { nodes, source, positions, path, originalError, extensions } =\n      toNormalizedArgs(rawArgs);\n    super(message);\n    this.name = 'GraphQLError';\n    this.path = path !== null && path !== void 0 ? path : undefined;\n    this.originalError =\n      originalError !== null && originalError !== void 0\n        ? originalError\n        : undefined; // Compute list of blame nodes.\n\n    this.nodes = undefinedIfEmpty(\n      Array.isArray(nodes) ? nodes : nodes ? [nodes] : undefined,\n    );\n    const nodeLocations = undefinedIfEmpty(\n      (_this$nodes = this.nodes) === null || _this$nodes === void 0\n        ? void 0\n        : _this$nodes.map((node) => node.loc).filter((loc) => loc != null),\n    ); // Compute locations in the source for the given nodes/positions.\n\n    this.source =\n      source !== null && source !== void 0\n        ? source\n        : nodeLocations === null || nodeLocations === void 0\n        ? void 0\n        : (_nodeLocations$ = nodeLocations[0]) === null ||\n          _nodeLocations$ === void 0\n        ? void 0\n        : _nodeLocations$.source;\n    this.positions =\n      positions !== null && positions !== void 0\n        ? positions\n        : nodeLocations === null || nodeLocations === void 0\n        ? void 0\n        : nodeLocations.map((loc) => loc.start);\n    this.locations =\n      positions && source\n        ? positions.map((pos) => getLocation(source, pos))\n        : nodeLocations === null || nodeLocations === void 0\n        ? void 0\n        : nodeLocations.map((loc) => getLocation(loc.source, loc.start));\n    const originalExtensions = isObjectLike(\n      originalError === null || originalError === void 0\n        ? void 0\n        : originalError.extensions,\n    )\n      ? originalError === null || originalError === void 0\n        ? void 0\n        : originalError.extensions\n      : undefined;\n    this.extensions =\n      (_ref =\n        extensions !== null && extensions !== void 0\n          ? extensions\n          : originalExtensions) !== null && _ref !== void 0\n        ? _ref\n        : Object.create(null); // Only properties prescribed by the spec should be enumerable.\n    // Keep the rest as non-enumerable.\n\n    Object.defineProperties(this, {\n      message: {\n        writable: true,\n        enumerable: true,\n      },\n      name: {\n        enumerable: false,\n      },\n      nodes: {\n        enumerable: false,\n      },\n      source: {\n        enumerable: false,\n      },\n      positions: {\n        enumerable: false,\n      },\n      originalError: {\n        enumerable: false,\n      },\n    }); // Include (non-enumerable) stack trace.\n\n    /* c8 ignore start */\n    // FIXME: https://github.com/graphql/graphql-js/issues/2317\n\n    if (\n      originalError !== null &&\n      originalError !== void 0 &&\n      originalError.stack\n    ) {\n      Object.defineProperty(this, 'stack', {\n        value: originalError.stack,\n        writable: true,\n        configurable: true,\n      });\n    } else if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, GraphQLError);\n    } else {\n      Object.defineProperty(this, 'stack', {\n        value: Error().stack,\n        writable: true,\n        configurable: true,\n      });\n    }\n    /* c8 ignore stop */\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'GraphQLError';\n  }\n\n  toString() {\n    let output = this.message;\n\n    if (this.nodes) {\n      for (const node of this.nodes) {\n        if (node.loc) {\n          output += '\\n\\n' + printLocation(node.loc);\n        }\n      }\n    } else if (this.source && this.locations) {\n      for (const location of this.locations) {\n        output += '\\n\\n' + printSourceLocation(this.source, location);\n      }\n    }\n\n    return output;\n  }\n\n  toJSON() {\n    const formattedError = {\n      message: this.message,\n    };\n\n    if (this.locations != null) {\n      formattedError.locations = this.locations;\n    }\n\n    if (this.path != null) {\n      formattedError.path = this.path;\n    }\n\n    if (this.extensions != null && Object.keys(this.extensions).length > 0) {\n      formattedError.extensions = this.extensions;\n    }\n\n    return formattedError;\n  }\n}\n\nfunction undefinedIfEmpty(array) {\n  return array === undefined || array.length === 0 ? undefined : array;\n}\n/**\n * See: https://spec.graphql.org/draft/#sec-Errors\n */\n\n/**\n * Prints a GraphQLError to a string, representing useful location information\n * about the error's position in the source.\n *\n * @deprecated Please use `error.toString` instead. Will be removed in v17\n */\nexport function printError(error) {\n  return error.toString();\n}\n/**\n * Given a GraphQLError, format it according to the rules described by the\n * Response Format, Errors section of the GraphQL Specification.\n *\n * @deprecated Please use `error.toString` instead. Will be removed in v17\n */\n\nexport function formatError(error) {\n  return error.toJSON();\n}\n","import { GraphQLError } from './GraphQLError.mjs';\n/**\n * Produces a GraphQLError representing a syntax error, containing useful\n * descriptive information about the syntax error's position in the source.\n */\n\nexport function syntaxError(source, position, description) {\n  return new GraphQLError(`Syntax Error: ${description}`, undefined, source, [\n    position,\n  ]);\n}\n","/**\n * The set of allowed directive location values.\n */\nexport let DirectiveLocation;\n/**\n * The enum type representing the directive location values.\n *\n * @deprecated Please use `DirectiveLocation`. Will be remove in v17.\n */\n\n(function (DirectiveLocation) {\n  DirectiveLocation['QUERY'] = 'QUERY';\n  DirectiveLocation['MUTATION'] = 'MUTATION';\n  DirectiveLocation['SUBSCRIPTION'] = 'SUBSCRIPTION';\n  DirectiveLocation['FIELD'] = 'FIELD';\n  DirectiveLocation['FRAGMENT_DEFINITION'] = 'FRAGMENT_DEFINITION';\n  DirectiveLocation['FRAGMENT_SPREAD'] = 'FRAGMENT_SPREAD';\n  DirectiveLocation['INLINE_FRAGMENT'] = 'INLINE_FRAGMENT';\n  DirectiveLocation['VARIABLE_DEFINITION'] = 'VARIABLE_DEFINITION';\n  DirectiveLocation['SCHEMA'] = 'SCHEMA';\n  DirectiveLocation['SCALAR'] = 'SCALAR';\n  DirectiveLocation['OBJECT'] = 'OBJECT';\n  DirectiveLocation['FIELD_DEFINITION'] = 'FIELD_DEFINITION';\n  DirectiveLocation['ARGUMENT_DEFINITION'] = 'ARGUMENT_DEFINITION';\n  DirectiveLocation['INTERFACE'] = 'INTERFACE';\n  DirectiveLocation['UNION'] = 'UNION';\n  DirectiveLocation['ENUM'] = 'ENUM';\n  DirectiveLocation['ENUM_VALUE'] = 'ENUM_VALUE';\n  DirectiveLocation['INPUT_OBJECT'] = 'INPUT_OBJECT';\n  DirectiveLocation['INPUT_FIELD_DEFINITION'] = 'INPUT_FIELD_DEFINITION';\n})(DirectiveLocation || (DirectiveLocation = {}));\n","/**\n * An exported enum describing the different kinds of tokens that the\n * lexer emits.\n */\nexport let TokenKind;\n/**\n * The enum type representing the token kinds values.\n *\n * @deprecated Please use `TokenKind`. Will be remove in v17.\n */\n\n(function (TokenKind) {\n  TokenKind['SOF'] = '<SOF>';\n  TokenKind['EOF'] = '<EOF>';\n  TokenKind['BANG'] = '!';\n  TokenKind['DOLLAR'] = '$';\n  TokenKind['AMP'] = '&';\n  TokenKind['PAREN_L'] = '(';\n  TokenKind['PAREN_R'] = ')';\n  TokenKind['SPREAD'] = '...';\n  TokenKind['COLON'] = ':';\n  TokenKind['EQUALS'] = '=';\n  TokenKind['AT'] = '@';\n  TokenKind['BRACKET_L'] = '[';\n  TokenKind['BRACKET_R'] = ']';\n  TokenKind['BRACE_L'] = '{';\n  TokenKind['PIPE'] = '|';\n  TokenKind['BRACE_R'] = '}';\n  TokenKind['NAME'] = 'Name';\n  TokenKind['INT'] = 'Int';\n  TokenKind['FLOAT'] = 'Float';\n  TokenKind['STRING'] = 'String';\n  TokenKind['BLOCK_STRING'] = 'BlockString';\n  TokenKind['COMMENT'] = 'Comment';\n})(TokenKind || (TokenKind = {}));\n","import { syntaxError } from '../error/syntaxError.mjs';\nimport { Token } from './ast.mjs';\nimport { dedentBlockStringLines } from './blockString.mjs';\nimport { isDigit, isNameContinue, isNameStart } from './characterClasses.mjs';\nimport { TokenKind } from './tokenKind.mjs';\n/**\n * Given a Source object, creates a Lexer for that source.\n * A Lexer is a stateful stream generator in that every time\n * it is advanced, it returns the next token in the Source. Assuming the\n * source lexes, the final Token emitted by the lexer will be of kind\n * EOF, after which the lexer will repeatedly return the same EOF token\n * whenever called.\n */\n\nexport class Lexer {\n  /**\n   * The previously focused non-ignored token.\n   */\n\n  /**\n   * The currently focused non-ignored token.\n   */\n\n  /**\n   * The (1-indexed) line containing the current token.\n   */\n\n  /**\n   * The character offset at which the current line begins.\n   */\n  constructor(source) {\n    const startOfFileToken = new Token(TokenKind.SOF, 0, 0, 0, 0);\n    this.source = source;\n    this.lastToken = startOfFileToken;\n    this.token = startOfFileToken;\n    this.line = 1;\n    this.lineStart = 0;\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'Lexer';\n  }\n  /**\n   * Advances the token stream to the next non-ignored token.\n   */\n\n  advance() {\n    this.lastToken = this.token;\n    const token = (this.token = this.lookahead());\n    return token;\n  }\n  /**\n   * Looks ahead and returns the next non-ignored token, but does not change\n   * the state of Lexer.\n   */\n\n  lookahead() {\n    let token = this.token;\n\n    if (token.kind !== TokenKind.EOF) {\n      do {\n        if (token.next) {\n          token = token.next;\n        } else {\n          // Read the next token and form a link in the token linked-list.\n          const nextToken = readNextToken(this, token.end); // @ts-expect-error next is only mutable during parsing.\n\n          token.next = nextToken; // @ts-expect-error prev is only mutable during parsing.\n\n          nextToken.prev = token;\n          token = nextToken;\n        }\n      } while (token.kind === TokenKind.COMMENT);\n    }\n\n    return token;\n  }\n}\n/**\n * @internal\n */\n\nexport function isPunctuatorTokenKind(kind) {\n  return (\n    kind === TokenKind.BANG ||\n    kind === TokenKind.DOLLAR ||\n    kind === TokenKind.AMP ||\n    kind === TokenKind.PAREN_L ||\n    kind === TokenKind.PAREN_R ||\n    kind === TokenKind.SPREAD ||\n    kind === TokenKind.COLON ||\n    kind === TokenKind.EQUALS ||\n    kind === TokenKind.AT ||\n    kind === TokenKind.BRACKET_L ||\n    kind === TokenKind.BRACKET_R ||\n    kind === TokenKind.BRACE_L ||\n    kind === TokenKind.PIPE ||\n    kind === TokenKind.BRACE_R\n  );\n}\n/**\n * A Unicode scalar value is any Unicode code point except surrogate code\n * points. In other words, the inclusive ranges of values 0x0000 to 0xD7FF and\n * 0xE000 to 0x10FFFF.\n *\n * SourceCharacter ::\n *   - \"Any Unicode scalar value\"\n */\n\nfunction isUnicodeScalarValue(code) {\n  return (\n    (code >= 0x0000 && code <= 0xd7ff) || (code >= 0xe000 && code <= 0x10ffff)\n  );\n}\n/**\n * The GraphQL specification defines source text as a sequence of unicode scalar\n * values (which Unicode defines to exclude surrogate code points). However\n * JavaScript defines strings as a sequence of UTF-16 code units which may\n * include surrogates. A surrogate pair is a valid source character as it\n * encodes a supplementary code point (above U+FFFF), but unpaired surrogate\n * code points are not valid source characters.\n */\n\nfunction isSupplementaryCodePoint(body, location) {\n  return (\n    isLeadingSurrogate(body.charCodeAt(location)) &&\n    isTrailingSurrogate(body.charCodeAt(location + 1))\n  );\n}\n\nfunction isLeadingSurrogate(code) {\n  return code >= 0xd800 && code <= 0xdbff;\n}\n\nfunction isTrailingSurrogate(code) {\n  return code >= 0xdc00 && code <= 0xdfff;\n}\n/**\n * Prints the code point (or end of file reference) at a given location in a\n * source for use in error messages.\n *\n * Printable ASCII is printed quoted, while other points are printed in Unicode\n * code point form (ie. U+1234).\n */\n\nfunction printCodePointAt(lexer, location) {\n  const code = lexer.source.body.codePointAt(location);\n\n  if (code === undefined) {\n    return TokenKind.EOF;\n  } else if (code >= 0x0020 && code <= 0x007e) {\n    // Printable ASCII\n    const char = String.fromCodePoint(code);\n    return char === '\"' ? \"'\\\"'\" : `\"${char}\"`;\n  } // Unicode code point\n\n  return 'U+' + code.toString(16).toUpperCase().padStart(4, '0');\n}\n/**\n * Create a token with line and column location information.\n */\n\nfunction createToken(lexer, kind, start, end, value) {\n  const line = lexer.line;\n  const col = 1 + start - lexer.lineStart;\n  return new Token(kind, start, end, line, col, value);\n}\n/**\n * Gets the next token from the source starting at the given position.\n *\n * This skips over whitespace until it finds the next lexable token, then lexes\n * punctuators immediately or calls the appropriate helper function for more\n * complicated tokens.\n */\n\nfunction readNextToken(lexer, start) {\n  const body = lexer.source.body;\n  const bodyLength = body.length;\n  let position = start;\n\n  while (position < bodyLength) {\n    const code = body.charCodeAt(position); // SourceCharacter\n\n    switch (code) {\n      // Ignored ::\n      //   - UnicodeBOM\n      //   - WhiteSpace\n      //   - LineTerminator\n      //   - Comment\n      //   - Comma\n      //\n      // UnicodeBOM :: \"Byte Order Mark (U+FEFF)\"\n      //\n      // WhiteSpace ::\n      //   - \"Horizontal Tab (U+0009)\"\n      //   - \"Space (U+0020)\"\n      //\n      // Comma :: ,\n      case 0xfeff: // <BOM>\n\n      case 0x0009: // \\t\n\n      case 0x0020: // <space>\n\n      case 0x002c:\n        // ,\n        ++position;\n        continue;\n      // LineTerminator ::\n      //   - \"New Line (U+000A)\"\n      //   - \"Carriage Return (U+000D)\" [lookahead != \"New Line (U+000A)\"]\n      //   - \"Carriage Return (U+000D)\" \"New Line (U+000A)\"\n\n      case 0x000a:\n        // \\n\n        ++position;\n        ++lexer.line;\n        lexer.lineStart = position;\n        continue;\n\n      case 0x000d:\n        // \\r\n        if (body.charCodeAt(position + 1) === 0x000a) {\n          position += 2;\n        } else {\n          ++position;\n        }\n\n        ++lexer.line;\n        lexer.lineStart = position;\n        continue;\n      // Comment\n\n      case 0x0023:\n        // #\n        return readComment(lexer, position);\n      // Token ::\n      //   - Punctuator\n      //   - Name\n      //   - IntValue\n      //   - FloatValue\n      //   - StringValue\n      //\n      // Punctuator :: one of ! $ & ( ) ... : = @ [ ] { | }\n\n      case 0x0021:\n        // !\n        return createToken(lexer, TokenKind.BANG, position, position + 1);\n\n      case 0x0024:\n        // $\n        return createToken(lexer, TokenKind.DOLLAR, position, position + 1);\n\n      case 0x0026:\n        // &\n        return createToken(lexer, TokenKind.AMP, position, position + 1);\n\n      case 0x0028:\n        // (\n        return createToken(lexer, TokenKind.PAREN_L, position, position + 1);\n\n      case 0x0029:\n        // )\n        return createToken(lexer, TokenKind.PAREN_R, position, position + 1);\n\n      case 0x002e:\n        // .\n        if (\n          body.charCodeAt(position + 1) === 0x002e &&\n          body.charCodeAt(position + 2) === 0x002e\n        ) {\n          return createToken(lexer, TokenKind.SPREAD, position, position + 3);\n        }\n\n        break;\n\n      case 0x003a:\n        // :\n        return createToken(lexer, TokenKind.COLON, position, position + 1);\n\n      case 0x003d:\n        // =\n        return createToken(lexer, TokenKind.EQUALS, position, position + 1);\n\n      case 0x0040:\n        // @\n        return createToken(lexer, TokenKind.AT, position, position + 1);\n\n      case 0x005b:\n        // [\n        return createToken(lexer, TokenKind.BRACKET_L, position, position + 1);\n\n      case 0x005d:\n        // ]\n        return createToken(lexer, TokenKind.BRACKET_R, position, position + 1);\n\n      case 0x007b:\n        // {\n        return createToken(lexer, TokenKind.BRACE_L, position, position + 1);\n\n      case 0x007c:\n        // |\n        return createToken(lexer, TokenKind.PIPE, position, position + 1);\n\n      case 0x007d:\n        // }\n        return createToken(lexer, TokenKind.BRACE_R, position, position + 1);\n      // StringValue\n\n      case 0x0022:\n        // \"\n        if (\n          body.charCodeAt(position + 1) === 0x0022 &&\n          body.charCodeAt(position + 2) === 0x0022\n        ) {\n          return readBlockString(lexer, position);\n        }\n\n        return readString(lexer, position);\n    } // IntValue | FloatValue (Digit | -)\n\n    if (isDigit(code) || code === 0x002d) {\n      return readNumber(lexer, position, code);\n    } // Name\n\n    if (isNameStart(code)) {\n      return readName(lexer, position);\n    }\n\n    throw syntaxError(\n      lexer.source,\n      position,\n      code === 0x0027\n        ? 'Unexpected single quote character (\\'), did you mean to use a double quote (\")?'\n        : isUnicodeScalarValue(code) || isSupplementaryCodePoint(body, position)\n        ? `Unexpected character: ${printCodePointAt(lexer, position)}.`\n        : `Invalid character: ${printCodePointAt(lexer, position)}.`,\n    );\n  }\n\n  return createToken(lexer, TokenKind.EOF, bodyLength, bodyLength);\n}\n/**\n * Reads a comment token from the source file.\n *\n * ```\n * Comment :: # CommentChar* [lookahead != CommentChar]\n *\n * CommentChar :: SourceCharacter but not LineTerminator\n * ```\n */\n\nfunction readComment(lexer, start) {\n  const body = lexer.source.body;\n  const bodyLength = body.length;\n  let position = start + 1;\n\n  while (position < bodyLength) {\n    const code = body.charCodeAt(position); // LineTerminator (\\n | \\r)\n\n    if (code === 0x000a || code === 0x000d) {\n      break;\n    } // SourceCharacter\n\n    if (isUnicodeScalarValue(code)) {\n      ++position;\n    } else if (isSupplementaryCodePoint(body, position)) {\n      position += 2;\n    } else {\n      break;\n    }\n  }\n\n  return createToken(\n    lexer,\n    TokenKind.COMMENT,\n    start,\n    position,\n    body.slice(start + 1, position),\n  );\n}\n/**\n * Reads a number token from the source file, either a FloatValue or an IntValue\n * depending on whether a FractionalPart or ExponentPart is encountered.\n *\n * ```\n * IntValue :: IntegerPart [lookahead != {Digit, `.`, NameStart}]\n *\n * IntegerPart ::\n *   - NegativeSign? 0\n *   - NegativeSign? NonZeroDigit Digit*\n *\n * NegativeSign :: -\n *\n * NonZeroDigit :: Digit but not `0`\n *\n * FloatValue ::\n *   - IntegerPart FractionalPart ExponentPart [lookahead != {Digit, `.`, NameStart}]\n *   - IntegerPart FractionalPart [lookahead != {Digit, `.`, NameStart}]\n *   - IntegerPart ExponentPart [lookahead != {Digit, `.`, NameStart}]\n *\n * FractionalPart :: . Digit+\n *\n * ExponentPart :: ExponentIndicator Sign? Digit+\n *\n * ExponentIndicator :: one of `e` `E`\n *\n * Sign :: one of + -\n * ```\n */\n\nfunction readNumber(lexer, start, firstCode) {\n  const body = lexer.source.body;\n  let position = start;\n  let code = firstCode;\n  let isFloat = false; // NegativeSign (-)\n\n  if (code === 0x002d) {\n    code = body.charCodeAt(++position);\n  } // Zero (0)\n\n  if (code === 0x0030) {\n    code = body.charCodeAt(++position);\n\n    if (isDigit(code)) {\n      throw syntaxError(\n        lexer.source,\n        position,\n        `Invalid number, unexpected digit after 0: ${printCodePointAt(\n          lexer,\n          position,\n        )}.`,\n      );\n    }\n  } else {\n    position = readDigits(lexer, position, code);\n    code = body.charCodeAt(position);\n  } // Full stop (.)\n\n  if (code === 0x002e) {\n    isFloat = true;\n    code = body.charCodeAt(++position);\n    position = readDigits(lexer, position, code);\n    code = body.charCodeAt(position);\n  } // E e\n\n  if (code === 0x0045 || code === 0x0065) {\n    isFloat = true;\n    code = body.charCodeAt(++position); // + -\n\n    if (code === 0x002b || code === 0x002d) {\n      code = body.charCodeAt(++position);\n    }\n\n    position = readDigits(lexer, position, code);\n    code = body.charCodeAt(position);\n  } // Numbers cannot be followed by . or NameStart\n\n  if (code === 0x002e || isNameStart(code)) {\n    throw syntaxError(\n      lexer.source,\n      position,\n      `Invalid number, expected digit but got: ${printCodePointAt(\n        lexer,\n        position,\n      )}.`,\n    );\n  }\n\n  return createToken(\n    lexer,\n    isFloat ? TokenKind.FLOAT : TokenKind.INT,\n    start,\n    position,\n    body.slice(start, position),\n  );\n}\n/**\n * Returns the new position in the source after reading one or more digits.\n */\n\nfunction readDigits(lexer, start, firstCode) {\n  if (!isDigit(firstCode)) {\n    throw syntaxError(\n      lexer.source,\n      start,\n      `Invalid number, expected digit but got: ${printCodePointAt(\n        lexer,\n        start,\n      )}.`,\n    );\n  }\n\n  const body = lexer.source.body;\n  let position = start + 1; // +1 to skip first firstCode\n\n  while (isDigit(body.charCodeAt(position))) {\n    ++position;\n  }\n\n  return position;\n}\n/**\n * Reads a single-quote string token from the source file.\n *\n * ```\n * StringValue ::\n *   - `\"\"` [lookahead != `\"`]\n *   - `\"` StringCharacter+ `\"`\n *\n * StringCharacter ::\n *   - SourceCharacter but not `\"` or `\\` or LineTerminator\n *   - `\\u` EscapedUnicode\n *   - `\\` EscapedCharacter\n *\n * EscapedUnicode ::\n *   - `{` HexDigit+ `}`\n *   - HexDigit HexDigit HexDigit HexDigit\n *\n * EscapedCharacter :: one of `\"` `\\` `/` `b` `f` `n` `r` `t`\n * ```\n */\n\nfunction readString(lexer, start) {\n  const body = lexer.source.body;\n  const bodyLength = body.length;\n  let position = start + 1;\n  let chunkStart = position;\n  let value = '';\n\n  while (position < bodyLength) {\n    const code = body.charCodeAt(position); // Closing Quote (\")\n\n    if (code === 0x0022) {\n      value += body.slice(chunkStart, position);\n      return createToken(lexer, TokenKind.STRING, start, position + 1, value);\n    } // Escape Sequence (\\)\n\n    if (code === 0x005c) {\n      value += body.slice(chunkStart, position);\n      const escape =\n        body.charCodeAt(position + 1) === 0x0075 // u\n          ? body.charCodeAt(position + 2) === 0x007b // {\n            ? readEscapedUnicodeVariableWidth(lexer, position)\n            : readEscapedUnicodeFixedWidth(lexer, position)\n          : readEscapedCharacter(lexer, position);\n      value += escape.value;\n      position += escape.size;\n      chunkStart = position;\n      continue;\n    } // LineTerminator (\\n | \\r)\n\n    if (code === 0x000a || code === 0x000d) {\n      break;\n    } // SourceCharacter\n\n    if (isUnicodeScalarValue(code)) {\n      ++position;\n    } else if (isSupplementaryCodePoint(body, position)) {\n      position += 2;\n    } else {\n      throw syntaxError(\n        lexer.source,\n        position,\n        `Invalid character within String: ${printCodePointAt(\n          lexer,\n          position,\n        )}.`,\n      );\n    }\n  }\n\n  throw syntaxError(lexer.source, position, 'Unterminated string.');\n} // The string value and lexed size of an escape sequence.\n\nfunction readEscapedUnicodeVariableWidth(lexer, position) {\n  const body = lexer.source.body;\n  let point = 0;\n  let size = 3; // Cannot be larger than 12 chars (\\u{00000000}).\n\n  while (size < 12) {\n    const code = body.charCodeAt(position + size++); // Closing Brace (})\n\n    if (code === 0x007d) {\n      // Must be at least 5 chars (\\u{0}) and encode a Unicode scalar value.\n      if (size < 5 || !isUnicodeScalarValue(point)) {\n        break;\n      }\n\n      return {\n        value: String.fromCodePoint(point),\n        size,\n      };\n    } // Append this hex digit to the code point.\n\n    point = (point << 4) | readHexDigit(code);\n\n    if (point < 0) {\n      break;\n    }\n  }\n\n  throw syntaxError(\n    lexer.source,\n    position,\n    `Invalid Unicode escape sequence: \"${body.slice(\n      position,\n      position + size,\n    )}\".`,\n  );\n}\n\nfunction readEscapedUnicodeFixedWidth(lexer, position) {\n  const body = lexer.source.body;\n  const code = read16BitHexCode(body, position + 2);\n\n  if (isUnicodeScalarValue(code)) {\n    return {\n      value: String.fromCodePoint(code),\n      size: 6,\n    };\n  } // GraphQL allows JSON-style surrogate pair escape sequences, but only when\n  // a valid pair is formed.\n\n  if (isLeadingSurrogate(code)) {\n    // \\u\n    if (\n      body.charCodeAt(position + 6) === 0x005c &&\n      body.charCodeAt(position + 7) === 0x0075\n    ) {\n      const trailingCode = read16BitHexCode(body, position + 8);\n\n      if (isTrailingSurrogate(trailingCode)) {\n        // JavaScript defines strings as a sequence of UTF-16 code units and\n        // encodes Unicode code points above U+FFFF using a surrogate pair of\n        // code units. Since this is a surrogate pair escape sequence, just\n        // include both codes into the JavaScript string value. Had JavaScript\n        // not been internally based on UTF-16, then this surrogate pair would\n        // be decoded to retrieve the supplementary code point.\n        return {\n          value: String.fromCodePoint(code, trailingCode),\n          size: 12,\n        };\n      }\n    }\n  }\n\n  throw syntaxError(\n    lexer.source,\n    position,\n    `Invalid Unicode escape sequence: \"${body.slice(position, position + 6)}\".`,\n  );\n}\n/**\n * Reads four hexadecimal characters and returns the positive integer that 16bit\n * hexadecimal string represents. For example, \"000f\" will return 15, and \"dead\"\n * will return 57005.\n *\n * Returns a negative number if any char was not a valid hexadecimal digit.\n */\n\nfunction read16BitHexCode(body, position) {\n  // readHexDigit() returns -1 on error. ORing a negative value with any other\n  // value always produces a negative value.\n  return (\n    (readHexDigit(body.charCodeAt(position)) << 12) |\n    (readHexDigit(body.charCodeAt(position + 1)) << 8) |\n    (readHexDigit(body.charCodeAt(position + 2)) << 4) |\n    readHexDigit(body.charCodeAt(position + 3))\n  );\n}\n/**\n * Reads a hexadecimal character and returns its positive integer value (0-15).\n *\n * '0' becomes 0, '9' becomes 9\n * 'A' becomes 10, 'F' becomes 15\n * 'a' becomes 10, 'f' becomes 15\n *\n * Returns -1 if the provided character code was not a valid hexadecimal digit.\n *\n * HexDigit :: one of\n *   - `0` `1` `2` `3` `4` `5` `6` `7` `8` `9`\n *   - `A` `B` `C` `D` `E` `F`\n *   - `a` `b` `c` `d` `e` `f`\n */\n\nfunction readHexDigit(code) {\n  return code >= 0x0030 && code <= 0x0039 // 0-9\n    ? code - 0x0030\n    : code >= 0x0041 && code <= 0x0046 // A-F\n    ? code - 0x0037\n    : code >= 0x0061 && code <= 0x0066 // a-f\n    ? code - 0x0057\n    : -1;\n}\n/**\n * | Escaped Character | Code Point | Character Name               |\n * | ----------------- | ---------- | ---------------------------- |\n * | `\"`               | U+0022     | double quote                 |\n * | `\\`               | U+005C     | reverse solidus (back slash) |\n * | `/`               | U+002F     | solidus (forward slash)      |\n * | `b`               | U+0008     | backspace                    |\n * | `f`               | U+000C     | form feed                    |\n * | `n`               | U+000A     | line feed (new line)         |\n * | `r`               | U+000D     | carriage return              |\n * | `t`               | U+0009     | horizontal tab               |\n */\n\nfunction readEscapedCharacter(lexer, position) {\n  const body = lexer.source.body;\n  const code = body.charCodeAt(position + 1);\n\n  switch (code) {\n    case 0x0022:\n      // \"\n      return {\n        value: '\\u0022',\n        size: 2,\n      };\n\n    case 0x005c:\n      // \\\n      return {\n        value: '\\u005c',\n        size: 2,\n      };\n\n    case 0x002f:\n      // /\n      return {\n        value: '\\u002f',\n        size: 2,\n      };\n\n    case 0x0062:\n      // b\n      return {\n        value: '\\u0008',\n        size: 2,\n      };\n\n    case 0x0066:\n      // f\n      return {\n        value: '\\u000c',\n        size: 2,\n      };\n\n    case 0x006e:\n      // n\n      return {\n        value: '\\u000a',\n        size: 2,\n      };\n\n    case 0x0072:\n      // r\n      return {\n        value: '\\u000d',\n        size: 2,\n      };\n\n    case 0x0074:\n      // t\n      return {\n        value: '\\u0009',\n        size: 2,\n      };\n  }\n\n  throw syntaxError(\n    lexer.source,\n    position,\n    `Invalid character escape sequence: \"${body.slice(\n      position,\n      position + 2,\n    )}\".`,\n  );\n}\n/**\n * Reads a block string token from the source file.\n *\n * ```\n * StringValue ::\n *   - `\"\"\"` BlockStringCharacter* `\"\"\"`\n *\n * BlockStringCharacter ::\n *   - SourceCharacter but not `\"\"\"` or `\\\"\"\"`\n *   - `\\\"\"\"`\n * ```\n */\n\nfunction readBlockString(lexer, start) {\n  const body = lexer.source.body;\n  const bodyLength = body.length;\n  let lineStart = lexer.lineStart;\n  let position = start + 3;\n  let chunkStart = position;\n  let currentLine = '';\n  const blockLines = [];\n\n  while (position < bodyLength) {\n    const code = body.charCodeAt(position); // Closing Triple-Quote (\"\"\")\n\n    if (\n      code === 0x0022 &&\n      body.charCodeAt(position + 1) === 0x0022 &&\n      body.charCodeAt(position + 2) === 0x0022\n    ) {\n      currentLine += body.slice(chunkStart, position);\n      blockLines.push(currentLine);\n      const token = createToken(\n        lexer,\n        TokenKind.BLOCK_STRING,\n        start,\n        position + 3, // Return a string of the lines joined with U+000A.\n        dedentBlockStringLines(blockLines).join('\\n'),\n      );\n      lexer.line += blockLines.length - 1;\n      lexer.lineStart = lineStart;\n      return token;\n    } // Escaped Triple-Quote (\\\"\"\")\n\n    if (\n      code === 0x005c &&\n      body.charCodeAt(position + 1) === 0x0022 &&\n      body.charCodeAt(position + 2) === 0x0022 &&\n      body.charCodeAt(position + 3) === 0x0022\n    ) {\n      currentLine += body.slice(chunkStart, position);\n      chunkStart = position + 1; // skip only slash\n\n      position += 4;\n      continue;\n    } // LineTerminator\n\n    if (code === 0x000a || code === 0x000d) {\n      currentLine += body.slice(chunkStart, position);\n      blockLines.push(currentLine);\n\n      if (code === 0x000d && body.charCodeAt(position + 1) === 0x000a) {\n        position += 2;\n      } else {\n        ++position;\n      }\n\n      currentLine = '';\n      chunkStart = position;\n      lineStart = position;\n      continue;\n    } // SourceCharacter\n\n    if (isUnicodeScalarValue(code)) {\n      ++position;\n    } else if (isSupplementaryCodePoint(body, position)) {\n      position += 2;\n    } else {\n      throw syntaxError(\n        lexer.source,\n        position,\n        `Invalid character within String: ${printCodePointAt(\n          lexer,\n          position,\n        )}.`,\n      );\n    }\n  }\n\n  throw syntaxError(lexer.source, position, 'Unterminated string.');\n}\n/**\n * Reads an alphanumeric + underscore name from the source.\n *\n * ```\n * Name ::\n *   - NameStart NameContinue* [lookahead != NameContinue]\n * ```\n */\n\nfunction readName(lexer, start) {\n  const body = lexer.source.body;\n  const bodyLength = body.length;\n  let position = start + 1;\n\n  while (position < bodyLength) {\n    const code = body.charCodeAt(position);\n\n    if (isNameContinue(code)) {\n      ++position;\n    } else {\n      break;\n    }\n  }\n\n  return createToken(\n    lexer,\n    TokenKind.NAME,\n    start,\n    position,\n    body.slice(start, position),\n  );\n}\n","import { syntaxError } from '../error/syntaxError.mjs';\nimport { Location, OperationTypeNode } from './ast.mjs';\nimport { DirectiveLocation } from './directiveLocation.mjs';\nimport { Kind } from './kinds.mjs';\nimport { isPunctuatorTokenKind, Lexer } from './lexer.mjs';\nimport { isSource, Source } from './source.mjs';\nimport { TokenKind } from './tokenKind.mjs';\n/**\n * Configuration options to control parser behavior\n */\n\n/**\n * Given a GraphQL source, parses it into a Document.\n * Throws GraphQLError if a syntax error is encountered.\n */\nexport function parse(source, options) {\n  const parser = new Parser(source, options);\n  return parser.parseDocument();\n}\n/**\n * Given a string containing a GraphQL value (ex. `[42]`), parse the AST for\n * that value.\n * Throws GraphQLError if a syntax error is encountered.\n *\n * This is useful within tools that operate upon GraphQL Values directly and\n * in isolation of complete GraphQL documents.\n *\n * Consider providing the results to the utility function: valueFromAST().\n */\n\nexport function parseValue(source, options) {\n  const parser = new Parser(source, options);\n  parser.expectToken(TokenKind.SOF);\n  const value = parser.parseValueLiteral(false);\n  parser.expectToken(TokenKind.EOF);\n  return value;\n}\n/**\n * Similar to parseValue(), but raises a parse error if it encounters a\n * variable. The return type will be a constant value.\n */\n\nexport function parseConstValue(source, options) {\n  const parser = new Parser(source, options);\n  parser.expectToken(TokenKind.SOF);\n  const value = parser.parseConstValueLiteral();\n  parser.expectToken(TokenKind.EOF);\n  return value;\n}\n/**\n * Given a string containing a GraphQL Type (ex. `[Int!]`), parse the AST for\n * that type.\n * Throws GraphQLError if a syntax error is encountered.\n *\n * This is useful within tools that operate upon GraphQL Types directly and\n * in isolation of complete GraphQL documents.\n *\n * Consider providing the results to the utility function: typeFromAST().\n */\n\nexport function parseType(source, options) {\n  const parser = new Parser(source, options);\n  parser.expectToken(TokenKind.SOF);\n  const type = parser.parseTypeReference();\n  parser.expectToken(TokenKind.EOF);\n  return type;\n}\n/**\n * This class is exported only to assist people in implementing their own parsers\n * without duplicating too much code and should be used only as last resort for cases\n * such as experimental syntax or if certain features could not be contributed upstream.\n *\n * It is still part of the internal API and is versioned, so any changes to it are never\n * considered breaking changes. If you still need to support multiple versions of the\n * library, please use the `versionInfo` variable for version detection.\n *\n * @internal\n */\n\nexport class Parser {\n  constructor(source, options) {\n    const sourceObj = isSource(source) ? source : new Source(source);\n    this._lexer = new Lexer(sourceObj);\n    this._options = options;\n  }\n  /**\n   * Converts a name lex token into a name parse node.\n   */\n\n  parseName() {\n    const token = this.expectToken(TokenKind.NAME);\n    return this.node(token, {\n      kind: Kind.NAME,\n      value: token.value,\n    });\n  } // Implements the parsing rules in the Document section.\n\n  /**\n   * Document : Definition+\n   */\n\n  parseDocument() {\n    return this.node(this._lexer.token, {\n      kind: Kind.DOCUMENT,\n      definitions: this.many(\n        TokenKind.SOF,\n        this.parseDefinition,\n        TokenKind.EOF,\n      ),\n    });\n  }\n  /**\n   * Definition :\n   *   - ExecutableDefinition\n   *   - TypeSystemDefinition\n   *   - TypeSystemExtension\n   *\n   * ExecutableDefinition :\n   *   - OperationDefinition\n   *   - FragmentDefinition\n   *\n   * TypeSystemDefinition :\n   *   - SchemaDefinition\n   *   - TypeDefinition\n   *   - DirectiveDefinition\n   *\n   * TypeDefinition :\n   *   - ScalarTypeDefinition\n   *   - ObjectTypeDefinition\n   *   - InterfaceTypeDefinition\n   *   - UnionTypeDefinition\n   *   - EnumTypeDefinition\n   *   - InputObjectTypeDefinition\n   */\n\n  parseDefinition() {\n    if (this.peek(TokenKind.BRACE_L)) {\n      return this.parseOperationDefinition();\n    } // Many definitions begin with a description and require a lookahead.\n\n    const hasDescription = this.peekDescription();\n    const keywordToken = hasDescription\n      ? this._lexer.lookahead()\n      : this._lexer.token;\n\n    if (keywordToken.kind === TokenKind.NAME) {\n      switch (keywordToken.value) {\n        case 'schema':\n          return this.parseSchemaDefinition();\n\n        case 'scalar':\n          return this.parseScalarTypeDefinition();\n\n        case 'type':\n          return this.parseObjectTypeDefinition();\n\n        case 'interface':\n          return this.parseInterfaceTypeDefinition();\n\n        case 'union':\n          return this.parseUnionTypeDefinition();\n\n        case 'enum':\n          return this.parseEnumTypeDefinition();\n\n        case 'input':\n          return this.parseInputObjectTypeDefinition();\n\n        case 'directive':\n          return this.parseDirectiveDefinition();\n      }\n\n      if (hasDescription) {\n        throw syntaxError(\n          this._lexer.source,\n          this._lexer.token.start,\n          'Unexpected description, descriptions are supported only on type definitions.',\n        );\n      }\n\n      switch (keywordToken.value) {\n        case 'query':\n        case 'mutation':\n        case 'subscription':\n          return this.parseOperationDefinition();\n\n        case 'fragment':\n          return this.parseFragmentDefinition();\n\n        case 'extend':\n          return this.parseTypeSystemExtension();\n      }\n    }\n\n    throw this.unexpected(keywordToken);\n  } // Implements the parsing rules in the Operations section.\n\n  /**\n   * OperationDefinition :\n   *  - SelectionSet\n   *  - OperationType Name? VariableDefinitions? Directives? SelectionSet\n   */\n\n  parseOperationDefinition() {\n    const start = this._lexer.token;\n\n    if (this.peek(TokenKind.BRACE_L)) {\n      return this.node(start, {\n        kind: Kind.OPERATION_DEFINITION,\n        operation: OperationTypeNode.QUERY,\n        name: undefined,\n        variableDefinitions: [],\n        directives: [],\n        selectionSet: this.parseSelectionSet(),\n      });\n    }\n\n    const operation = this.parseOperationType();\n    let name;\n\n    if (this.peek(TokenKind.NAME)) {\n      name = this.parseName();\n    }\n\n    return this.node(start, {\n      kind: Kind.OPERATION_DEFINITION,\n      operation,\n      name,\n      variableDefinitions: this.parseVariableDefinitions(),\n      directives: this.parseDirectives(false),\n      selectionSet: this.parseSelectionSet(),\n    });\n  }\n  /**\n   * OperationType : one of query mutation subscription\n   */\n\n  parseOperationType() {\n    const operationToken = this.expectToken(TokenKind.NAME);\n\n    switch (operationToken.value) {\n      case 'query':\n        return OperationTypeNode.QUERY;\n\n      case 'mutation':\n        return OperationTypeNode.MUTATION;\n\n      case 'subscription':\n        return OperationTypeNode.SUBSCRIPTION;\n    }\n\n    throw this.unexpected(operationToken);\n  }\n  /**\n   * VariableDefinitions : ( VariableDefinition+ )\n   */\n\n  parseVariableDefinitions() {\n    return this.optionalMany(\n      TokenKind.PAREN_L,\n      this.parseVariableDefinition,\n      TokenKind.PAREN_R,\n    );\n  }\n  /**\n   * VariableDefinition : Variable : Type DefaultValue? Directives[Const]?\n   */\n\n  parseVariableDefinition() {\n    return this.node(this._lexer.token, {\n      kind: Kind.VARIABLE_DEFINITION,\n      variable: this.parseVariable(),\n      type: (this.expectToken(TokenKind.COLON), this.parseTypeReference()),\n      defaultValue: this.expectOptionalToken(TokenKind.EQUALS)\n        ? this.parseConstValueLiteral()\n        : undefined,\n      directives: this.parseConstDirectives(),\n    });\n  }\n  /**\n   * Variable : $ Name\n   */\n\n  parseVariable() {\n    const start = this._lexer.token;\n    this.expectToken(TokenKind.DOLLAR);\n    return this.node(start, {\n      kind: Kind.VARIABLE,\n      name: this.parseName(),\n    });\n  }\n  /**\n   * ```\n   * SelectionSet : { Selection+ }\n   * ```\n   */\n\n  parseSelectionSet() {\n    return this.node(this._lexer.token, {\n      kind: Kind.SELECTION_SET,\n      selections: this.many(\n        TokenKind.BRACE_L,\n        this.parseSelection,\n        TokenKind.BRACE_R,\n      ),\n    });\n  }\n  /**\n   * Selection :\n   *   - Field\n   *   - FragmentSpread\n   *   - InlineFragment\n   */\n\n  parseSelection() {\n    return this.peek(TokenKind.SPREAD)\n      ? this.parseFragment()\n      : this.parseField();\n  }\n  /**\n   * Field : Alias? Name Arguments? Directives? SelectionSet?\n   *\n   * Alias : Name :\n   */\n\n  parseField() {\n    const start = this._lexer.token;\n    const nameOrAlias = this.parseName();\n    let alias;\n    let name;\n\n    if (this.expectOptionalToken(TokenKind.COLON)) {\n      alias = nameOrAlias;\n      name = this.parseName();\n    } else {\n      name = nameOrAlias;\n    }\n\n    return this.node(start, {\n      kind: Kind.FIELD,\n      alias,\n      name,\n      arguments: this.parseArguments(false),\n      directives: this.parseDirectives(false),\n      selectionSet: this.peek(TokenKind.BRACE_L)\n        ? this.parseSelectionSet()\n        : undefined,\n    });\n  }\n  /**\n   * Arguments[Const] : ( Argument[?Const]+ )\n   */\n\n  parseArguments(isConst) {\n    const item = isConst ? this.parseConstArgument : this.parseArgument;\n    return this.optionalMany(TokenKind.PAREN_L, item, TokenKind.PAREN_R);\n  }\n  /**\n   * Argument[Const] : Name : Value[?Const]\n   */\n\n  parseArgument(isConst = false) {\n    const start = this._lexer.token;\n    const name = this.parseName();\n    this.expectToken(TokenKind.COLON);\n    return this.node(start, {\n      kind: Kind.ARGUMENT,\n      name,\n      value: this.parseValueLiteral(isConst),\n    });\n  }\n\n  parseConstArgument() {\n    return this.parseArgument(true);\n  } // Implements the parsing rules in the Fragments section.\n\n  /**\n   * Corresponds to both FragmentSpread and InlineFragment in the spec.\n   *\n   * FragmentSpread : ... FragmentName Directives?\n   *\n   * InlineFragment : ... TypeCondition? Directives? SelectionSet\n   */\n\n  parseFragment() {\n    const start = this._lexer.token;\n    this.expectToken(TokenKind.SPREAD);\n    const hasTypeCondition = this.expectOptionalKeyword('on');\n\n    if (!hasTypeCondition && this.peek(TokenKind.NAME)) {\n      return this.node(start, {\n        kind: Kind.FRAGMENT_SPREAD,\n        name: this.parseFragmentName(),\n        directives: this.parseDirectives(false),\n      });\n    }\n\n    return this.node(start, {\n      kind: Kind.INLINE_FRAGMENT,\n      typeCondition: hasTypeCondition ? this.parseNamedType() : undefined,\n      directives: this.parseDirectives(false),\n      selectionSet: this.parseSelectionSet(),\n    });\n  }\n  /**\n   * FragmentDefinition :\n   *   - fragment FragmentName on TypeCondition Directives? SelectionSet\n   *\n   * TypeCondition : NamedType\n   */\n\n  parseFragmentDefinition() {\n    var _this$_options;\n\n    const start = this._lexer.token;\n    this.expectKeyword('fragment'); // Legacy support for defining variables within fragments changes\n    // the grammar of FragmentDefinition:\n    //   - fragment FragmentName VariableDefinitions? on TypeCondition Directives? SelectionSet\n\n    if (\n      ((_this$_options = this._options) === null || _this$_options === void 0\n        ? void 0\n        : _this$_options.allowLegacyFragmentVariables) === true\n    ) {\n      return this.node(start, {\n        kind: Kind.FRAGMENT_DEFINITION,\n        name: this.parseFragmentName(),\n        variableDefinitions: this.parseVariableDefinitions(),\n        typeCondition: (this.expectKeyword('on'), this.parseNamedType()),\n        directives: this.parseDirectives(false),\n        selectionSet: this.parseSelectionSet(),\n      });\n    }\n\n    return this.node(start, {\n      kind: Kind.FRAGMENT_DEFINITION,\n      name: this.parseFragmentName(),\n      typeCondition: (this.expectKeyword('on'), this.parseNamedType()),\n      directives: this.parseDirectives(false),\n      selectionSet: this.parseSelectionSet(),\n    });\n  }\n  /**\n   * FragmentName : Name but not `on`\n   */\n\n  parseFragmentName() {\n    if (this._lexer.token.value === 'on') {\n      throw this.unexpected();\n    }\n\n    return this.parseName();\n  } // Implements the parsing rules in the Values section.\n\n  /**\n   * Value[Const] :\n   *   - [~Const] Variable\n   *   - IntValue\n   *   - FloatValue\n   *   - StringValue\n   *   - BooleanValue\n   *   - NullValue\n   *   - EnumValue\n   *   - ListValue[?Const]\n   *   - ObjectValue[?Const]\n   *\n   * BooleanValue : one of `true` `false`\n   *\n   * NullValue : `null`\n   *\n   * EnumValue : Name but not `true`, `false` or `null`\n   */\n\n  parseValueLiteral(isConst) {\n    const token = this._lexer.token;\n\n    switch (token.kind) {\n      case TokenKind.BRACKET_L:\n        return this.parseList(isConst);\n\n      case TokenKind.BRACE_L:\n        return this.parseObject(isConst);\n\n      case TokenKind.INT:\n        this._lexer.advance();\n\n        return this.node(token, {\n          kind: Kind.INT,\n          value: token.value,\n        });\n\n      case TokenKind.FLOAT:\n        this._lexer.advance();\n\n        return this.node(token, {\n          kind: Kind.FLOAT,\n          value: token.value,\n        });\n\n      case TokenKind.STRING:\n      case TokenKind.BLOCK_STRING:\n        return this.parseStringLiteral();\n\n      case TokenKind.NAME:\n        this._lexer.advance();\n\n        switch (token.value) {\n          case 'true':\n            return this.node(token, {\n              kind: Kind.BOOLEAN,\n              value: true,\n            });\n\n          case 'false':\n            return this.node(token, {\n              kind: Kind.BOOLEAN,\n              value: false,\n            });\n\n          case 'null':\n            return this.node(token, {\n              kind: Kind.NULL,\n            });\n\n          default:\n            return this.node(token, {\n              kind: Kind.ENUM,\n              value: token.value,\n            });\n        }\n\n      case TokenKind.DOLLAR:\n        if (isConst) {\n          this.expectToken(TokenKind.DOLLAR);\n\n          if (this._lexer.token.kind === TokenKind.NAME) {\n            const varName = this._lexer.token.value;\n            throw syntaxError(\n              this._lexer.source,\n              token.start,\n              `Unexpected variable \"$${varName}\" in constant value.`,\n            );\n          } else {\n            throw this.unexpected(token);\n          }\n        }\n\n        return this.parseVariable();\n\n      default:\n        throw this.unexpected();\n    }\n  }\n\n  parseConstValueLiteral() {\n    return this.parseValueLiteral(true);\n  }\n\n  parseStringLiteral() {\n    const token = this._lexer.token;\n\n    this._lexer.advance();\n\n    return this.node(token, {\n      kind: Kind.STRING,\n      value: token.value,\n      block: token.kind === TokenKind.BLOCK_STRING,\n    });\n  }\n  /**\n   * ListValue[Const] :\n   *   - [ ]\n   *   - [ Value[?Const]+ ]\n   */\n\n  parseList(isConst) {\n    const item = () => this.parseValueLiteral(isConst);\n\n    return this.node(this._lexer.token, {\n      kind: Kind.LIST,\n      values: this.any(TokenKind.BRACKET_L, item, TokenKind.BRACKET_R),\n    });\n  }\n  /**\n   * ```\n   * ObjectValue[Const] :\n   *   - { }\n   *   - { ObjectField[?Const]+ }\n   * ```\n   */\n\n  parseObject(isConst) {\n    const item = () => this.parseObjectField(isConst);\n\n    return this.node(this._lexer.token, {\n      kind: Kind.OBJECT,\n      fields: this.any(TokenKind.BRACE_L, item, TokenKind.BRACE_R),\n    });\n  }\n  /**\n   * ObjectField[Const] : Name : Value[?Const]\n   */\n\n  parseObjectField(isConst) {\n    const start = this._lexer.token;\n    const name = this.parseName();\n    this.expectToken(TokenKind.COLON);\n    return this.node(start, {\n      kind: Kind.OBJECT_FIELD,\n      name,\n      value: this.parseValueLiteral(isConst),\n    });\n  } // Implements the parsing rules in the Directives section.\n\n  /**\n   * Directives[Const] : Directive[?Const]+\n   */\n\n  parseDirectives(isConst) {\n    const directives = [];\n\n    while (this.peek(TokenKind.AT)) {\n      directives.push(this.parseDirective(isConst));\n    }\n\n    return directives;\n  }\n\n  parseConstDirectives() {\n    return this.parseDirectives(true);\n  }\n  /**\n   * ```\n   * Directive[Const] : @ Name Arguments[?Const]?\n   * ```\n   */\n\n  parseDirective(isConst) {\n    const start = this._lexer.token;\n    this.expectToken(TokenKind.AT);\n    return this.node(start, {\n      kind: Kind.DIRECTIVE,\n      name: this.parseName(),\n      arguments: this.parseArguments(isConst),\n    });\n  } // Implements the parsing rules in the Types section.\n\n  /**\n   * Type :\n   *   - NamedType\n   *   - ListType\n   *   - NonNullType\n   */\n\n  parseTypeReference() {\n    const start = this._lexer.token;\n    let type;\n\n    if (this.expectOptionalToken(TokenKind.BRACKET_L)) {\n      const innerType = this.parseTypeReference();\n      this.expectToken(TokenKind.BRACKET_R);\n      type = this.node(start, {\n        kind: Kind.LIST_TYPE,\n        type: innerType,\n      });\n    } else {\n      type = this.parseNamedType();\n    }\n\n    if (this.expectOptionalToken(TokenKind.BANG)) {\n      return this.node(start, {\n        kind: Kind.NON_NULL_TYPE,\n        type,\n      });\n    }\n\n    return type;\n  }\n  /**\n   * NamedType : Name\n   */\n\n  parseNamedType() {\n    return this.node(this._lexer.token, {\n      kind: Kind.NAMED_TYPE,\n      name: this.parseName(),\n    });\n  } // Implements the parsing rules in the Type Definition section.\n\n  peekDescription() {\n    return this.peek(TokenKind.STRING) || this.peek(TokenKind.BLOCK_STRING);\n  }\n  /**\n   * Description : StringValue\n   */\n\n  parseDescription() {\n    if (this.peekDescription()) {\n      return this.parseStringLiteral();\n    }\n  }\n  /**\n   * ```\n   * SchemaDefinition : Description? schema Directives[Const]? { OperationTypeDefinition+ }\n   * ```\n   */\n\n  parseSchemaDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    this.expectKeyword('schema');\n    const directives = this.parseConstDirectives();\n    const operationTypes = this.many(\n      TokenKind.BRACE_L,\n      this.parseOperationTypeDefinition,\n      TokenKind.BRACE_R,\n    );\n    return this.node(start, {\n      kind: Kind.SCHEMA_DEFINITION,\n      description,\n      directives,\n      operationTypes,\n    });\n  }\n  /**\n   * OperationTypeDefinition : OperationType : NamedType\n   */\n\n  parseOperationTypeDefinition() {\n    const start = this._lexer.token;\n    const operation = this.parseOperationType();\n    this.expectToken(TokenKind.COLON);\n    const type = this.parseNamedType();\n    return this.node(start, {\n      kind: Kind.OPERATION_TYPE_DEFINITION,\n      operation,\n      type,\n    });\n  }\n  /**\n   * ScalarTypeDefinition : Description? scalar Name Directives[Const]?\n   */\n\n  parseScalarTypeDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    this.expectKeyword('scalar');\n    const name = this.parseName();\n    const directives = this.parseConstDirectives();\n    return this.node(start, {\n      kind: Kind.SCALAR_TYPE_DEFINITION,\n      description,\n      name,\n      directives,\n    });\n  }\n  /**\n   * ObjectTypeDefinition :\n   *   Description?\n   *   type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition?\n   */\n\n  parseObjectTypeDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    this.expectKeyword('type');\n    const name = this.parseName();\n    const interfaces = this.parseImplementsInterfaces();\n    const directives = this.parseConstDirectives();\n    const fields = this.parseFieldsDefinition();\n    return this.node(start, {\n      kind: Kind.OBJECT_TYPE_DEFINITION,\n      description,\n      name,\n      interfaces,\n      directives,\n      fields,\n    });\n  }\n  /**\n   * ImplementsInterfaces :\n   *   - implements `&`? NamedType\n   *   - ImplementsInterfaces & NamedType\n   */\n\n  parseImplementsInterfaces() {\n    return this.expectOptionalKeyword('implements')\n      ? this.delimitedMany(TokenKind.AMP, this.parseNamedType)\n      : [];\n  }\n  /**\n   * ```\n   * FieldsDefinition : { FieldDefinition+ }\n   * ```\n   */\n\n  parseFieldsDefinition() {\n    return this.optionalMany(\n      TokenKind.BRACE_L,\n      this.parseFieldDefinition,\n      TokenKind.BRACE_R,\n    );\n  }\n  /**\n   * FieldDefinition :\n   *   - Description? Name ArgumentsDefinition? : Type Directives[Const]?\n   */\n\n  parseFieldDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    const name = this.parseName();\n    const args = this.parseArgumentDefs();\n    this.expectToken(TokenKind.COLON);\n    const type = this.parseTypeReference();\n    const directives = this.parseConstDirectives();\n    return this.node(start, {\n      kind: Kind.FIELD_DEFINITION,\n      description,\n      name,\n      arguments: args,\n      type,\n      directives,\n    });\n  }\n  /**\n   * ArgumentsDefinition : ( InputValueDefinition+ )\n   */\n\n  parseArgumentDefs() {\n    return this.optionalMany(\n      TokenKind.PAREN_L,\n      this.parseInputValueDef,\n      TokenKind.PAREN_R,\n    );\n  }\n  /**\n   * InputValueDefinition :\n   *   - Description? Name : Type DefaultValue? Directives[Const]?\n   */\n\n  parseInputValueDef() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    const name = this.parseName();\n    this.expectToken(TokenKind.COLON);\n    const type = this.parseTypeReference();\n    let defaultValue;\n\n    if (this.expectOptionalToken(TokenKind.EQUALS)) {\n      defaultValue = this.parseConstValueLiteral();\n    }\n\n    const directives = this.parseConstDirectives();\n    return this.node(start, {\n      kind: Kind.INPUT_VALUE_DEFINITION,\n      description,\n      name,\n      type,\n      defaultValue,\n      directives,\n    });\n  }\n  /**\n   * InterfaceTypeDefinition :\n   *   - Description? interface Name Directives[Const]? FieldsDefinition?\n   */\n\n  parseInterfaceTypeDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    this.expectKeyword('interface');\n    const name = this.parseName();\n    const interfaces = this.parseImplementsInterfaces();\n    const directives = this.parseConstDirectives();\n    const fields = this.parseFieldsDefinition();\n    return this.node(start, {\n      kind: Kind.INTERFACE_TYPE_DEFINITION,\n      description,\n      name,\n      interfaces,\n      directives,\n      fields,\n    });\n  }\n  /**\n   * UnionTypeDefinition :\n   *   - Description? union Name Directives[Const]? UnionMemberTypes?\n   */\n\n  parseUnionTypeDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    this.expectKeyword('union');\n    const name = this.parseName();\n    const directives = this.parseConstDirectives();\n    const types = this.parseUnionMemberTypes();\n    return this.node(start, {\n      kind: Kind.UNION_TYPE_DEFINITION,\n      description,\n      name,\n      directives,\n      types,\n    });\n  }\n  /**\n   * UnionMemberTypes :\n   *   - = `|`? NamedType\n   *   - UnionMemberTypes | NamedType\n   */\n\n  parseUnionMemberTypes() {\n    return this.expectOptionalToken(TokenKind.EQUALS)\n      ? this.delimitedMany(TokenKind.PIPE, this.parseNamedType)\n      : [];\n  }\n  /**\n   * EnumTypeDefinition :\n   *   - Description? enum Name Directives[Const]? EnumValuesDefinition?\n   */\n\n  parseEnumTypeDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    this.expectKeyword('enum');\n    const name = this.parseName();\n    const directives = this.parseConstDirectives();\n    const values = this.parseEnumValuesDefinition();\n    return this.node(start, {\n      kind: Kind.ENUM_TYPE_DEFINITION,\n      description,\n      name,\n      directives,\n      values,\n    });\n  }\n  /**\n   * ```\n   * EnumValuesDefinition : { EnumValueDefinition+ }\n   * ```\n   */\n\n  parseEnumValuesDefinition() {\n    return this.optionalMany(\n      TokenKind.BRACE_L,\n      this.parseEnumValueDefinition,\n      TokenKind.BRACE_R,\n    );\n  }\n  /**\n   * EnumValueDefinition : Description? EnumValue Directives[Const]?\n   */\n\n  parseEnumValueDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    const name = this.parseEnumValueName();\n    const directives = this.parseConstDirectives();\n    return this.node(start, {\n      kind: Kind.ENUM_VALUE_DEFINITION,\n      description,\n      name,\n      directives,\n    });\n  }\n  /**\n   * EnumValue : Name but not `true`, `false` or `null`\n   */\n\n  parseEnumValueName() {\n    if (\n      this._lexer.token.value === 'true' ||\n      this._lexer.token.value === 'false' ||\n      this._lexer.token.value === 'null'\n    ) {\n      throw syntaxError(\n        this._lexer.source,\n        this._lexer.token.start,\n        `${getTokenDesc(\n          this._lexer.token,\n        )} is reserved and cannot be used for an enum value.`,\n      );\n    }\n\n    return this.parseName();\n  }\n  /**\n   * InputObjectTypeDefinition :\n   *   - Description? input Name Directives[Const]? InputFieldsDefinition?\n   */\n\n  parseInputObjectTypeDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    this.expectKeyword('input');\n    const name = this.parseName();\n    const directives = this.parseConstDirectives();\n    const fields = this.parseInputFieldsDefinition();\n    return this.node(start, {\n      kind: Kind.INPUT_OBJECT_TYPE_DEFINITION,\n      description,\n      name,\n      directives,\n      fields,\n    });\n  }\n  /**\n   * ```\n   * InputFieldsDefinition : { InputValueDefinition+ }\n   * ```\n   */\n\n  parseInputFieldsDefinition() {\n    return this.optionalMany(\n      TokenKind.BRACE_L,\n      this.parseInputValueDef,\n      TokenKind.BRACE_R,\n    );\n  }\n  /**\n   * TypeSystemExtension :\n   *   - SchemaExtension\n   *   - TypeExtension\n   *\n   * TypeExtension :\n   *   - ScalarTypeExtension\n   *   - ObjectTypeExtension\n   *   - InterfaceTypeExtension\n   *   - UnionTypeExtension\n   *   - EnumTypeExtension\n   *   - InputObjectTypeDefinition\n   */\n\n  parseTypeSystemExtension() {\n    const keywordToken = this._lexer.lookahead();\n\n    if (keywordToken.kind === TokenKind.NAME) {\n      switch (keywordToken.value) {\n        case 'schema':\n          return this.parseSchemaExtension();\n\n        case 'scalar':\n          return this.parseScalarTypeExtension();\n\n        case 'type':\n          return this.parseObjectTypeExtension();\n\n        case 'interface':\n          return this.parseInterfaceTypeExtension();\n\n        case 'union':\n          return this.parseUnionTypeExtension();\n\n        case 'enum':\n          return this.parseEnumTypeExtension();\n\n        case 'input':\n          return this.parseInputObjectTypeExtension();\n      }\n    }\n\n    throw this.unexpected(keywordToken);\n  }\n  /**\n   * ```\n   * SchemaExtension :\n   *  - extend schema Directives[Const]? { OperationTypeDefinition+ }\n   *  - extend schema Directives[Const]\n   * ```\n   */\n\n  parseSchemaExtension() {\n    const start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('schema');\n    const directives = this.parseConstDirectives();\n    const operationTypes = this.optionalMany(\n      TokenKind.BRACE_L,\n      this.parseOperationTypeDefinition,\n      TokenKind.BRACE_R,\n    );\n\n    if (directives.length === 0 && operationTypes.length === 0) {\n      throw this.unexpected();\n    }\n\n    return this.node(start, {\n      kind: Kind.SCHEMA_EXTENSION,\n      directives,\n      operationTypes,\n    });\n  }\n  /**\n   * ScalarTypeExtension :\n   *   - extend scalar Name Directives[Const]\n   */\n\n  parseScalarTypeExtension() {\n    const start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('scalar');\n    const name = this.parseName();\n    const directives = this.parseConstDirectives();\n\n    if (directives.length === 0) {\n      throw this.unexpected();\n    }\n\n    return this.node(start, {\n      kind: Kind.SCALAR_TYPE_EXTENSION,\n      name,\n      directives,\n    });\n  }\n  /**\n   * ObjectTypeExtension :\n   *  - extend type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition\n   *  - extend type Name ImplementsInterfaces? Directives[Const]\n   *  - extend type Name ImplementsInterfaces\n   */\n\n  parseObjectTypeExtension() {\n    const start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('type');\n    const name = this.parseName();\n    const interfaces = this.parseImplementsInterfaces();\n    const directives = this.parseConstDirectives();\n    const fields = this.parseFieldsDefinition();\n\n    if (\n      interfaces.length === 0 &&\n      directives.length === 0 &&\n      fields.length === 0\n    ) {\n      throw this.unexpected();\n    }\n\n    return this.node(start, {\n      kind: Kind.OBJECT_TYPE_EXTENSION,\n      name,\n      interfaces,\n      directives,\n      fields,\n    });\n  }\n  /**\n   * InterfaceTypeExtension :\n   *  - extend interface Name ImplementsInterfaces? Directives[Const]? FieldsDefinition\n   *  - extend interface Name ImplementsInterfaces? Directives[Const]\n   *  - extend interface Name ImplementsInterfaces\n   */\n\n  parseInterfaceTypeExtension() {\n    const start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('interface');\n    const name = this.parseName();\n    const interfaces = this.parseImplementsInterfaces();\n    const directives = this.parseConstDirectives();\n    const fields = this.parseFieldsDefinition();\n\n    if (\n      interfaces.length === 0 &&\n      directives.length === 0 &&\n      fields.length === 0\n    ) {\n      throw this.unexpected();\n    }\n\n    return this.node(start, {\n      kind: Kind.INTERFACE_TYPE_EXTENSION,\n      name,\n      interfaces,\n      directives,\n      fields,\n    });\n  }\n  /**\n   * UnionTypeExtension :\n   *   - extend union Name Directives[Const]? UnionMemberTypes\n   *   - extend union Name Directives[Const]\n   */\n\n  parseUnionTypeExtension() {\n    const start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('union');\n    const name = this.parseName();\n    const directives = this.parseConstDirectives();\n    const types = this.parseUnionMemberTypes();\n\n    if (directives.length === 0 && types.length === 0) {\n      throw this.unexpected();\n    }\n\n    return this.node(start, {\n      kind: Kind.UNION_TYPE_EXTENSION,\n      name,\n      directives,\n      types,\n    });\n  }\n  /**\n   * EnumTypeExtension :\n   *   - extend enum Name Directives[Const]? EnumValuesDefinition\n   *   - extend enum Name Directives[Const]\n   */\n\n  parseEnumTypeExtension() {\n    const start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('enum');\n    const name = this.parseName();\n    const directives = this.parseConstDirectives();\n    const values = this.parseEnumValuesDefinition();\n\n    if (directives.length === 0 && values.length === 0) {\n      throw this.unexpected();\n    }\n\n    return this.node(start, {\n      kind: Kind.ENUM_TYPE_EXTENSION,\n      name,\n      directives,\n      values,\n    });\n  }\n  /**\n   * InputObjectTypeExtension :\n   *   - extend input Name Directives[Const]? InputFieldsDefinition\n   *   - extend input Name Directives[Const]\n   */\n\n  parseInputObjectTypeExtension() {\n    const start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('input');\n    const name = this.parseName();\n    const directives = this.parseConstDirectives();\n    const fields = this.parseInputFieldsDefinition();\n\n    if (directives.length === 0 && fields.length === 0) {\n      throw this.unexpected();\n    }\n\n    return this.node(start, {\n      kind: Kind.INPUT_OBJECT_TYPE_EXTENSION,\n      name,\n      directives,\n      fields,\n    });\n  }\n  /**\n   * ```\n   * DirectiveDefinition :\n   *   - Description? directive @ Name ArgumentsDefinition? `repeatable`? on DirectiveLocations\n   * ```\n   */\n\n  parseDirectiveDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    this.expectKeyword('directive');\n    this.expectToken(TokenKind.AT);\n    const name = this.parseName();\n    const args = this.parseArgumentDefs();\n    const repeatable = this.expectOptionalKeyword('repeatable');\n    this.expectKeyword('on');\n    const locations = this.parseDirectiveLocations();\n    return this.node(start, {\n      kind: Kind.DIRECTIVE_DEFINITION,\n      description,\n      name,\n      arguments: args,\n      repeatable,\n      locations,\n    });\n  }\n  /**\n   * DirectiveLocations :\n   *   - `|`? DirectiveLocation\n   *   - DirectiveLocations | DirectiveLocation\n   */\n\n  parseDirectiveLocations() {\n    return this.delimitedMany(TokenKind.PIPE, this.parseDirectiveLocation);\n  }\n  /*\n   * DirectiveLocation :\n   *   - ExecutableDirectiveLocation\n   *   - TypeSystemDirectiveLocation\n   *\n   * ExecutableDirectiveLocation : one of\n   *   `QUERY`\n   *   `MUTATION`\n   *   `SUBSCRIPTION`\n   *   `FIELD`\n   *   `FRAGMENT_DEFINITION`\n   *   `FRAGMENT_SPREAD`\n   *   `INLINE_FRAGMENT`\n   *\n   * TypeSystemDirectiveLocation : one of\n   *   `SCHEMA`\n   *   `SCALAR`\n   *   `OBJECT`\n   *   `FIELD_DEFINITION`\n   *   `ARGUMENT_DEFINITION`\n   *   `INTERFACE`\n   *   `UNION`\n   *   `ENUM`\n   *   `ENUM_VALUE`\n   *   `INPUT_OBJECT`\n   *   `INPUT_FIELD_DEFINITION`\n   */\n\n  parseDirectiveLocation() {\n    const start = this._lexer.token;\n    const name = this.parseName();\n\n    if (Object.prototype.hasOwnProperty.call(DirectiveLocation, name.value)) {\n      return name;\n    }\n\n    throw this.unexpected(start);\n  } // Core parsing utility functions\n\n  /**\n   * Returns a node that, if configured to do so, sets a \"loc\" field as a\n   * location object, used to identify the place in the source that created a\n   * given parsed object.\n   */\n\n  node(startToken, node) {\n    var _this$_options2;\n\n    if (\n      ((_this$_options2 = this._options) === null || _this$_options2 === void 0\n        ? void 0\n        : _this$_options2.noLocation) !== true\n    ) {\n      node.loc = new Location(\n        startToken,\n        this._lexer.lastToken,\n        this._lexer.source,\n      );\n    }\n\n    return node;\n  }\n  /**\n   * Determines if the next token is of a given kind\n   */\n\n  peek(kind) {\n    return this._lexer.token.kind === kind;\n  }\n  /**\n   * If the next token is of the given kind, return that token after advancing the lexer.\n   * Otherwise, do not change the parser state and throw an error.\n   */\n\n  expectToken(kind) {\n    const token = this._lexer.token;\n\n    if (token.kind === kind) {\n      this._lexer.advance();\n\n      return token;\n    }\n\n    throw syntaxError(\n      this._lexer.source,\n      token.start,\n      `Expected ${getTokenKindDesc(kind)}, found ${getTokenDesc(token)}.`,\n    );\n  }\n  /**\n   * If the next token is of the given kind, return \"true\" after advancing the lexer.\n   * Otherwise, do not change the parser state and return \"false\".\n   */\n\n  expectOptionalToken(kind) {\n    const token = this._lexer.token;\n\n    if (token.kind === kind) {\n      this._lexer.advance();\n\n      return true;\n    }\n\n    return false;\n  }\n  /**\n   * If the next token is a given keyword, advance the lexer.\n   * Otherwise, do not change the parser state and throw an error.\n   */\n\n  expectKeyword(value) {\n    const token = this._lexer.token;\n\n    if (token.kind === TokenKind.NAME && token.value === value) {\n      this._lexer.advance();\n    } else {\n      throw syntaxError(\n        this._lexer.source,\n        token.start,\n        `Expected \"${value}\", found ${getTokenDesc(token)}.`,\n      );\n    }\n  }\n  /**\n   * If the next token is a given keyword, return \"true\" after advancing the lexer.\n   * Otherwise, do not change the parser state and return \"false\".\n   */\n\n  expectOptionalKeyword(value) {\n    const token = this._lexer.token;\n\n    if (token.kind === TokenKind.NAME && token.value === value) {\n      this._lexer.advance();\n\n      return true;\n    }\n\n    return false;\n  }\n  /**\n   * Helper function for creating an error when an unexpected lexed token is encountered.\n   */\n\n  unexpected(atToken) {\n    const token =\n      atToken !== null && atToken !== void 0 ? atToken : this._lexer.token;\n    return syntaxError(\n      this._lexer.source,\n      token.start,\n      `Unexpected ${getTokenDesc(token)}.`,\n    );\n  }\n  /**\n   * Returns a possibly empty list of parse nodes, determined by the parseFn.\n   * This list begins with a lex token of openKind and ends with a lex token of closeKind.\n   * Advances the parser to the next lex token after the closing token.\n   */\n\n  any(openKind, parseFn, closeKind) {\n    this.expectToken(openKind);\n    const nodes = [];\n\n    while (!this.expectOptionalToken(closeKind)) {\n      nodes.push(parseFn.call(this));\n    }\n\n    return nodes;\n  }\n  /**\n   * Returns a list of parse nodes, determined by the parseFn.\n   * It can be empty only if open token is missing otherwise it will always return non-empty list\n   * that begins with a lex token of openKind and ends with a lex token of closeKind.\n   * Advances the parser to the next lex token after the closing token.\n   */\n\n  optionalMany(openKind, parseFn, closeKind) {\n    if (this.expectOptionalToken(openKind)) {\n      const nodes = [];\n\n      do {\n        nodes.push(parseFn.call(this));\n      } while (!this.expectOptionalToken(closeKind));\n\n      return nodes;\n    }\n\n    return [];\n  }\n  /**\n   * Returns a non-empty list of parse nodes, determined by the parseFn.\n   * This list begins with a lex token of openKind and ends with a lex token of closeKind.\n   * Advances the parser to the next lex token after the closing token.\n   */\n\n  many(openKind, parseFn, closeKind) {\n    this.expectToken(openKind);\n    const nodes = [];\n\n    do {\n      nodes.push(parseFn.call(this));\n    } while (!this.expectOptionalToken(closeKind));\n\n    return nodes;\n  }\n  /**\n   * Returns a non-empty list of parse nodes, determined by the parseFn.\n   * This list may begin with a lex token of delimiterKind followed by items separated by lex tokens of tokenKind.\n   * Advances the parser to the next lex token after last item in the list.\n   */\n\n  delimitedMany(delimiterKind, parseFn) {\n    this.expectOptionalToken(delimiterKind);\n    const nodes = [];\n\n    do {\n      nodes.push(parseFn.call(this));\n    } while (this.expectOptionalToken(delimiterKind));\n\n    return nodes;\n  }\n}\n/**\n * A helper function to describe a token as a string for debugging.\n */\n\nfunction getTokenDesc(token) {\n  const value = token.value;\n  return getTokenKindDesc(token.kind) + (value != null ? ` \"${value}\"` : '');\n}\n/**\n * A helper function to describe a token kind as a string for debugging.\n */\n\nfunction getTokenKindDesc(kind) {\n  return isPunctuatorTokenKind(kind) ? `\"${kind}\"` : kind;\n}\n","import { __assign } from \"tslib\";\nimport { parse } from 'graphql';\nvar docCache = new Map();\nvar fragmentSourceMap = new Map();\nvar printFragmentWarnings = true;\nvar experimentalFragmentVariables = false;\nfunction normalize(string) {\n    return string.replace(/[\\s,]+/g, ' ').trim();\n}\nfunction cacheKeyFromLoc(loc) {\n    return normalize(loc.source.body.substring(loc.start, loc.end));\n}\nfunction processFragments(ast) {\n    var seenKeys = new Set();\n    var definitions = [];\n    ast.definitions.forEach(function (fragmentDefinition) {\n        if (fragmentDefinition.kind === 'FragmentDefinition') {\n            var fragmentName = fragmentDefinition.name.value;\n            var sourceKey = cacheKeyFromLoc(fragmentDefinition.loc);\n            var sourceKeySet = fragmentSourceMap.get(fragmentName);\n            if (sourceKeySet && !sourceKeySet.has(sourceKey)) {\n                if (printFragmentWarnings) {\n                    console.warn(\"Warning: fragment with name \" + fragmentName + \" already exists.\\n\"\n                        + \"graphql-tag enforces all fragment names across your application to be unique; read more about\\n\"\n                        + \"this in the docs: http://dev.apollodata.com/core/fragments.html#unique-names\");\n                }\n            }\n            else if (!sourceKeySet) {\n                fragmentSourceMap.set(fragmentName, sourceKeySet = new Set);\n            }\n            sourceKeySet.add(sourceKey);\n            if (!seenKeys.has(sourceKey)) {\n                seenKeys.add(sourceKey);\n                definitions.push(fragmentDefinition);\n            }\n        }\n        else {\n            definitions.push(fragmentDefinition);\n        }\n    });\n    return __assign(__assign({}, ast), { definitions: definitions });\n}\nfunction stripLoc(doc) {\n    var workSet = new Set(doc.definitions);\n    workSet.forEach(function (node) {\n        if (node.loc)\n            delete node.loc;\n        Object.keys(node).forEach(function (key) {\n            var value = node[key];\n            if (value && typeof value === 'object') {\n                workSet.add(value);\n            }\n        });\n    });\n    var loc = doc.loc;\n    if (loc) {\n        delete loc.startToken;\n        delete loc.endToken;\n    }\n    return doc;\n}\nfunction parseDocument(source) {\n    var cacheKey = normalize(source);\n    if (!docCache.has(cacheKey)) {\n        var parsed = parse(source, {\n            experimentalFragmentVariables: experimentalFragmentVariables,\n            allowLegacyFragmentVariables: experimentalFragmentVariables\n        });\n        if (!parsed || parsed.kind !== 'Document') {\n            throw new Error('Not a valid GraphQL document.');\n        }\n        docCache.set(cacheKey, stripLoc(processFragments(parsed)));\n    }\n    return docCache.get(cacheKey);\n}\nexport function gql(literals) {\n    var args = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        args[_i - 1] = arguments[_i];\n    }\n    if (typeof literals === 'string') {\n        literals = [literals];\n    }\n    var result = literals[0];\n    args.forEach(function (arg, i) {\n        if (arg && arg.kind === 'Document') {\n            result += arg.loc.source.body;\n        }\n        else {\n            result += arg;\n        }\n        result += literals[i + 1];\n    });\n    return parseDocument(result);\n}\nexport function resetCaches() {\n    docCache.clear();\n    fragmentSourceMap.clear();\n}\nexport function disableFragmentWarnings() {\n    printFragmentWarnings = false;\n}\nexport function enableExperimentalFragmentVariables() {\n    experimentalFragmentVariables = true;\n}\nexport function disableExperimentalFragmentVariables() {\n    experimentalFragmentVariables = false;\n}\nvar extras = {\n    gql: gql,\n    resetCaches: resetCaches,\n    disableFragmentWarnings: disableFragmentWarnings,\n    enableExperimentalFragmentVariables: enableExperimentalFragmentVariables,\n    disableExperimentalFragmentVariables: disableExperimentalFragmentVariables\n};\n(function (gql_1) {\n    gql_1.gql = extras.gql, gql_1.resetCaches = extras.resetCaches, gql_1.disableFragmentWarnings = extras.disableFragmentWarnings, gql_1.enableExperimentalFragmentVariables = extras.enableExperimentalFragmentVariables, gql_1.disableExperimentalFragmentVariables = extras.disableExperimentalFragmentVariables;\n})(gql || (gql = {}));\ngql[\"default\"] = gql;\nexport default gql;\n//# sourceMappingURL=index.js.map","import memoize from '@emotion/memoize';\n\nvar reactPropsRegex = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|download|draggable|encType|enterKeyHint|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/; // https://esbench.com/bench/5bfee68a4cd7e6009ef61d23\n\nvar isPropValid = /* #__PURE__ */memoize(function (prop) {\n  return reactPropsRegex.test(prop) || prop.charCodeAt(0) === 111\n  /* o */\n  && prop.charCodeAt(1) === 110\n  /* n */\n  && prop.charCodeAt(2) < 91;\n}\n/* Z+1 */\n);\n\nexport default isPropValid;\n","import _extends from '@babel/runtime/helpers/esm/extends';\nimport { useContext, createElement, Fragment } from 'react';\nimport isPropValid from '@emotion/is-prop-valid';\nimport { withEmotionCache, ThemeContext } from '@emotion/react';\nimport { getRegisteredStyles, insertStyles } from '@emotion/utils';\nimport { serializeStyles } from '@emotion/serialize';\n\nvar testOmitPropsOnStringTag = isPropValid;\n\nvar testOmitPropsOnComponent = function testOmitPropsOnComponent(key) {\n  return key !== 'theme';\n};\n\nvar getDefaultShouldForwardProp = function getDefaultShouldForwardProp(tag) {\n  return typeof tag === 'string' && // 96 is one less than the char code\n  // for \"a\" so this is checking that\n  // it's a lowercase character\n  tag.charCodeAt(0) > 96 ? testOmitPropsOnStringTag : testOmitPropsOnComponent;\n};\nvar composeShouldForwardProps = function composeShouldForwardProps(tag, options, isReal) {\n  var shouldForwardProp;\n\n  if (options) {\n    var optionsShouldForwardProp = options.shouldForwardProp;\n    shouldForwardProp = tag.__emotion_forwardProp && optionsShouldForwardProp ? function (propName) {\n      return tag.__emotion_forwardProp(propName) && optionsShouldForwardProp(propName);\n    } : optionsShouldForwardProp;\n  }\n\n  if (typeof shouldForwardProp !== 'function' && isReal) {\n    shouldForwardProp = tag.__emotion_forwardProp;\n  }\n\n  return shouldForwardProp;\n};\n\nvar ILLEGAL_ESCAPE_SEQUENCE_ERROR = \"You have illegal escape sequence in your template literal, most likely inside content's property value.\\nBecause you write your CSS inside a JavaScript string you actually have to do double escaping, so for example \\\"content: '\\\\00d7';\\\" should become \\\"content: '\\\\\\\\00d7';\\\".\\nYou can read more about this here:\\nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#ES2018_revision_of_illegal_escape_sequences\";\n\nvar Noop = function Noop() {\n  return null;\n};\n\nvar createStyled = function createStyled(tag, options) {\n  if (process.env.NODE_ENV !== 'production') {\n    if (tag === undefined) {\n      throw new Error('You are trying to create a styled element with an undefined component.\\nYou may have forgotten to import it.');\n    }\n  }\n\n  var isReal = tag.__emotion_real === tag;\n  var baseTag = isReal && tag.__emotion_base || tag;\n  var identifierName;\n  var targetClassName;\n\n  if (options !== undefined) {\n    identifierName = options.label;\n    targetClassName = options.target;\n  }\n\n  var shouldForwardProp = composeShouldForwardProps(tag, options, isReal);\n  var defaultShouldForwardProp = shouldForwardProp || getDefaultShouldForwardProp(baseTag);\n  var shouldUseAs = !defaultShouldForwardProp('as');\n  return function () {\n    var args = arguments;\n    var styles = isReal && tag.__emotion_styles !== undefined ? tag.__emotion_styles.slice(0) : [];\n\n    if (identifierName !== undefined) {\n      styles.push(\"label:\" + identifierName + \";\");\n    }\n\n    if (args[0] == null || args[0].raw === undefined) {\n      styles.push.apply(styles, args);\n    } else {\n      if (process.env.NODE_ENV !== 'production' && args[0][0] === undefined) {\n        console.error(ILLEGAL_ESCAPE_SEQUENCE_ERROR);\n      }\n\n      styles.push(args[0][0]);\n      var len = args.length;\n      var i = 1;\n\n      for (; i < len; i++) {\n        if (process.env.NODE_ENV !== 'production' && args[0][i] === undefined) {\n          console.error(ILLEGAL_ESCAPE_SEQUENCE_ERROR);\n        }\n\n        styles.push(args[i], args[0][i]);\n      }\n    } // $FlowFixMe: we need to cast StatelessFunctionalComponent to our PrivateStyledComponent class\n\n\n    var Styled = withEmotionCache(function (props, cache, ref) {\n      var finalTag = shouldUseAs && props.as || baseTag;\n      var className = '';\n      var classInterpolations = [];\n      var mergedProps = props;\n\n      if (props.theme == null) {\n        mergedProps = {};\n\n        for (var key in props) {\n          mergedProps[key] = props[key];\n        }\n\n        mergedProps.theme = useContext(ThemeContext);\n      }\n\n      if (typeof props.className === 'string') {\n        className = getRegisteredStyles(cache.registered, classInterpolations, props.className);\n      } else if (props.className != null) {\n        className = props.className + \" \";\n      }\n\n      var serialized = serializeStyles(styles.concat(classInterpolations), cache.registered, mergedProps);\n      var rules = insertStyles(cache, serialized, typeof finalTag === 'string');\n      className += cache.key + \"-\" + serialized.name;\n\n      if (targetClassName !== undefined) {\n        className += \" \" + targetClassName;\n      }\n\n      var finalShouldForwardProp = shouldUseAs && shouldForwardProp === undefined ? getDefaultShouldForwardProp(finalTag) : defaultShouldForwardProp;\n      var newProps = {};\n\n      for (var _key in props) {\n        if (shouldUseAs && _key === 'as') continue;\n\n        if ( // $FlowFixMe\n        finalShouldForwardProp(_key)) {\n          newProps[_key] = props[_key];\n        }\n      }\n\n      newProps.className = className;\n      newProps.ref = ref;\n      var ele = /*#__PURE__*/createElement(finalTag, newProps);\n      var possiblyStyleElement = /*#__PURE__*/createElement(Noop, null);\n\n\n      return /*#__PURE__*/createElement(Fragment, null, possiblyStyleElement, ele);\n    });\n    Styled.displayName = identifierName !== undefined ? identifierName : \"Styled(\" + (typeof baseTag === 'string' ? baseTag : baseTag.displayName || baseTag.name || 'Component') + \")\";\n    Styled.defaultProps = tag.defaultProps;\n    Styled.__emotion_real = Styled;\n    Styled.__emotion_base = baseTag;\n    Styled.__emotion_styles = styles;\n    Styled.__emotion_forwardProp = shouldForwardProp;\n    Object.defineProperty(Styled, 'toString', {\n      value: function value() {\n        if (targetClassName === undefined && process.env.NODE_ENV !== 'production') {\n          return 'NO_COMPONENT_SELECTOR';\n        } // $FlowFixMe: coerce undefined to string\n\n\n        return \".\" + targetClassName;\n      }\n    });\n\n    Styled.withComponent = function (nextTag, nextOptions) {\n      return createStyled(nextTag, _extends({}, options, nextOptions, {\n        shouldForwardProp: composeShouldForwardProps(Styled, nextOptions, true)\n      })).apply(void 0, styles);\n    };\n\n    return Styled;\n  };\n};\n\nexport default createStyled;\n","import '@babel/runtime/helpers/extends';\nimport 'react';\nimport '@emotion/is-prop-valid';\nimport createStyled from '../base/dist/emotion-styled-base.browser.esm.js';\nimport '@emotion/react';\nimport '@emotion/utils';\nimport '@emotion/serialize';\n\nvar tags = ['a', 'abbr', 'address', 'area', 'article', 'aside', 'audio', 'b', 'base', 'bdi', 'bdo', 'big', 'blockquote', 'body', 'br', 'button', 'canvas', 'caption', 'cite', 'code', 'col', 'colgroup', 'data', 'datalist', 'dd', 'del', 'details', 'dfn', 'dialog', 'div', 'dl', 'dt', 'em', 'embed', 'fieldset', 'figcaption', 'figure', 'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'i', 'iframe', 'img', 'input', 'ins', 'kbd', 'keygen', 'label', 'legend', 'li', 'link', 'main', 'map', 'mark', 'marquee', 'menu', 'menuitem', 'meta', 'meter', 'nav', 'noscript', 'object', 'ol', 'optgroup', 'option', 'output', 'p', 'param', 'picture', 'pre', 'progress', 'q', 'rp', 'rt', 'ruby', 's', 'samp', 'script', 'section', 'select', 'small', 'source', 'span', 'strong', 'style', 'sub', 'summary', 'sup', 'table', 'tbody', 'td', 'textarea', 'tfoot', 'th', 'thead', 'time', 'title', 'tr', 'track', 'u', 'ul', 'var', 'video', 'wbr', // SVG\n'circle', 'clipPath', 'defs', 'ellipse', 'foreignObject', 'g', 'image', 'line', 'linearGradient', 'mask', 'path', 'pattern', 'polygon', 'polyline', 'radialGradient', 'rect', 'stop', 'svg', 'text', 'tspan'];\n\nvar newStyled = createStyled.bind();\ntags.forEach(function (tagName) {\n  // $FlowFixMe: we can ignore this because its exposed type is defined by the CreateStyled type\n  newStyled[tagName] = newStyled(tagName);\n});\n\nexport default newStyled;\n","import { invariant } from '../../utilities/globals';\nimport { useContext } from 'react';\nimport { ApolloClient } from '../../core';\nimport { getApolloContext } from '../context';\n\nexport function useApolloClient(\n  override?: ApolloClient<object>,\n): ApolloClient<object> {\n  const context = useContext(getApolloContext());\n  const client = override || context.client;\n  invariant(\n    !!client,\n    'Could not find \"client\" in the context or passed in as an option. ' +\n    'Wrap the root component in an <ApolloProvider>, or pass an ApolloClient ' +\n    'instance in via options.',\n  );\n\n  return client;\n}\n","import { invariant } from '../../utilities/globals';\n\nimport {\n  DocumentNode,\n  DefinitionNode,\n  VariableDefinitionNode,\n  OperationDefinitionNode\n} from 'graphql';\n\nexport enum DocumentType {\n  Query,\n  Mutation,\n  Subscription\n}\n\nexport interface IDocumentDefinition {\n  type: DocumentType;\n  name: string;\n  variables: ReadonlyArray<VariableDefinitionNode>;\n}\n\nconst cache = new Map();\n\nexport function operationName(type: DocumentType) {\n  let name;\n  switch (type) {\n    case DocumentType.Query:\n      name = 'Query';\n      break;\n    case DocumentType.Mutation:\n      name = 'Mutation';\n      break;\n    case DocumentType.Subscription:\n      name = 'Subscription';\n      break;\n  }\n  return name;\n}\n\n// This parser is mostly used to safety check incoming documents.\nexport function parser(document: DocumentNode): IDocumentDefinition {\n  const cached = cache.get(document);\n  if (cached) return cached;\n\n  let variables, type, name;\n\n  invariant(\n    !!document && !!document.kind,\n    `Argument of ${document} passed to parser was not a valid GraphQL ` +\n      `DocumentNode. You may need to use 'graphql-tag' or another method ` +\n      `to convert your operation into a document`\n  );\n\n  const fragments = document.definitions.filter(\n    (x: DefinitionNode) => x.kind === 'FragmentDefinition'\n  );\n\n  const queries = document.definitions.filter(\n    (x: DefinitionNode) =>\n      x.kind === 'OperationDefinition' && x.operation === 'query'\n  );\n\n  const mutations = document.definitions.filter(\n    (x: DefinitionNode) =>\n      x.kind === 'OperationDefinition' && x.operation === 'mutation'\n  );\n\n  const subscriptions = document.definitions.filter(\n    (x: DefinitionNode) =>\n      x.kind === 'OperationDefinition' && x.operation === 'subscription'\n  );\n\n  invariant(\n    !fragments.length ||\n      (queries.length || mutations.length || subscriptions.length),\n    `Passing only a fragment to 'graphql' is not yet supported. ` +\n      `You must include a query, subscription or mutation as well`\n  );\n\n  invariant(\n    queries.length + mutations.length + subscriptions.length <= 1,\n    `react-apollo only supports a query, subscription, or a mutation per HOC. ` +\n      `${document} had ${queries.length} queries, ${subscriptions.length} ` +\n      `subscriptions and ${mutations.length} mutations. ` +\n      `You can use 'compose' to join multiple operation types to a component`\n  );\n\n  type = queries.length ? DocumentType.Query : DocumentType.Mutation;\n  if (!queries.length && !mutations.length) type = DocumentType.Subscription;\n\n  const definitions = queries.length\n    ? queries\n    : mutations.length\n    ? mutations\n    : subscriptions;\n\n  invariant(\n    definitions.length === 1,\n    `react-apollo only supports one definition per HOC. ${document} had ` +\n      `${definitions.length} definitions. ` +\n      `You can use 'compose' to join multiple operation types to a component`\n  );\n\n  const definition = definitions[0] as OperationDefinitionNode;\n  variables = definition.variableDefinitions || [];\n\n  if (definition.name && definition.name.kind === 'Name') {\n    name = definition.name.value;\n  } else {\n    name = 'data'; // fallback to using data if no name\n  }\n\n  const payload = { name, type, variables };\n  cache.set(document, payload);\n  return payload;\n}\n\nexport function verifyDocumentType(document: DocumentNode, type: DocumentType) {\n  const operation = parser(document);\n  const requiredOperationName = operationName(type);\n  const usedOperationName = operationName(operation.type);\n  invariant(\n    operation.type === type,\n    `Running a ${requiredOperationName} requires a graphql ` +\n      `${requiredOperationName}, but a ${usedOperationName} was used instead.`\n  );\n}\n\n","import setPrototypeOf from \"./setPrototypeOf.js\";\nexport default function _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  Object.defineProperty(subClass, \"prototype\", {\n    writable: false\n  });\n  if (superClass) setPrototypeOf(subClass, superClass);\n}","import _typeof from \"./typeof.js\";\nimport assertThisInitialized from \"./assertThisInitialized.js\";\nexport default function _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  } else if (call !== void 0) {\n    throw new TypeError(\"Derived constructors may only return object or undefined\");\n  }\n\n  return assertThisInitialized(self);\n}","import getPrototypeOf from \"./getPrototypeOf.js\";\nimport isNativeReflectConstruct from \"./isNativeReflectConstruct.js\";\nimport possibleConstructorReturn from \"./possibleConstructorReturn.js\";\nexport default function _createSuper(Derived) {\n  var hasNativeReflectConstruct = isNativeReflectConstruct();\n  return function _createSuperInternal() {\n    var Super = getPrototypeOf(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = getPrototypeOf(this).constructor;\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return possibleConstructorReturn(this, result);\n  };\n}","export default function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n  }, _typeof(obj);\n}","export default function _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}","export default function _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}","export default function _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}","export default function _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}","import setPrototypeOf from \"./setPrototypeOf.js\";\nimport isNativeReflectConstruct from \"./isNativeReflectConstruct.js\";\nexport default function _construct(Parent, args, Class) {\n  if (isNativeReflectConstruct()) {\n    _construct = Reflect.construct;\n  } else {\n    _construct = function _construct(Parent, args, Class) {\n      var a = [null];\n      a.push.apply(a, args);\n      var Constructor = Function.bind.apply(Parent, a);\n      var instance = new Constructor();\n      if (Class) setPrototypeOf(instance, Class.prototype);\n      return instance;\n    };\n  }\n\n  return _construct.apply(null, arguments);\n}","import getPrototypeOf from \"./getPrototypeOf.js\";\nimport setPrototypeOf from \"./setPrototypeOf.js\";\nimport isNativeFunction from \"./isNativeFunction.js\";\nimport construct from \"./construct.js\";\nexport default function _wrapNativeSuper(Class) {\n  var _cache = typeof Map === \"function\" ? new Map() : undefined;\n\n  _wrapNativeSuper = function _wrapNativeSuper(Class) {\n    if (Class === null || !isNativeFunction(Class)) return Class;\n\n    if (typeof Class !== \"function\") {\n      throw new TypeError(\"Super expression must either be null or a function\");\n    }\n\n    if (typeof _cache !== \"undefined\") {\n      if (_cache.has(Class)) return _cache.get(Class);\n\n      _cache.set(Class, Wrapper);\n    }\n\n    function Wrapper() {\n      return construct(Class, arguments, getPrototypeOf(this).constructor);\n    }\n\n    Wrapper.prototype = Object.create(Class.prototype, {\n      constructor: {\n        value: Wrapper,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n    return setPrototypeOf(Wrapper, Class);\n  };\n\n  return _wrapNativeSuper(Class);\n}","export default function _isNativeFunction(fn) {\n  return Function.toString.call(fn).indexOf(\"[native code]\") !== -1;\n}"],"sourceRoot":""}